commit c067d9ac706e9d1dd76e6e48f5f1e13c888c4746
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 01:16:23 2026 +0900

    feat(hexagon): expand hex grid from radius 2 (19 tiles) to radius 3 (37 tiles)

diff --git a/script.js b/script.js
index a855f90..ee55ae1 100644
--- a/script.js
+++ b/script.js
@@ -2771,16 +2771,16 @@ class UnitessGalleryApp {
                 ctx.restore();
             }
             else {
-                // Modified Hexagon Grid: 19-hex cluster (Pointy-Top)
-                const size = w / 9.5;
+                // Modified Hexagon Grid: 37-hex cluster (Pointy-Top)
+                const size = w / 13;
                 ctx.save(); // CRITICAL: Stop translation accumulation
                 ctx.translate(w / 2, h / 2);
 
-                // Define axial coordinates for a radius-2 hexagon (19 tiles)
+                // Define axial coordinates for a radius-3 hexagon (37 tiles)
                 const hexPositions = [];
-                for (let r = -2; r <= 2; r++) {
-                    for (let q = -2; q <= 2; q++) {
-                        if (Math.abs(q + r) <= 2) {
+                for (let r = -3; r <= 3; r++) {
+                    for (let q = -3; q <= 3; q++) {
+                        if (Math.abs(q + r) <= 3) {
                             hexPositions.push({ q, r });
                         }
                     }
@@ -2814,9 +2814,9 @@ class UnitessGalleryApp {
                     ctx.closePath();
                     ctx.stroke();
 
-                    // 3. Draw ID Label (1-19)
+                    // 3. Draw ID Label
                     ctx.fillStyle = "rgba(0,0,0,0.3)";
-                    ctx.font = "bold 9px Arial";
+                    ctx.font = "bold 8px Arial";
                     ctx.textAlign = "center";
                     ctx.textBaseline = "middle";
                     ctx.fillText(idx + 1, 0, 0);

commit 6c0413c4a14988703583a426a2c0d3fb9cb9db6e
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 01:06:19 2026 +0900

    fix(triangle): correct 6th row tiles for T2 and T4 based on user mappings

diff --git a/script.js b/script.js
index 5487a55..a855f90 100644
--- a/script.js
+++ b/script.js
@@ -2860,7 +2860,7 @@ class UnitessGalleryApp {
                         [0, 0], [1, 120], [0, 0], [0, 0], [1, 120],
                         [1, 120], [0, 0], [0, 0], [1, 120], [1, 120],
                         // Row 6 additions
-                        [0, 0], [0, 0], [1, 120], [1, 120], [0, 0], [0, 0], [1, 120], [1, 120], [0, 0], [0, 0], [1, 120]
+                        [1, 120], [0, 0], [1, 120], [1, 120], [1, 120], [0, 0], [1, 120], [1, 120], [1, 120], [0, 0], [1, 120]
                     ];
                     // Manual Overrides requested previously:
                     // 1=(2,5,9,10,14) -> [1,120]. 14 is idx 13 (0-based)
@@ -2901,7 +2901,7 @@ class UnitessGalleryApp {
                         [1, 0], [0, 0], [1, 0], [0, 0], [1, 0],
                         [0, 0], [1, 0], [0, 0], [1, 0], [0, 0],
                         // Row 6 additions
-                        [1, 0], [0, 0], [1, 0], [0, 0], [1, 0], [0, 0], [1, 0], [0, 0], [1, 0], [0, 0], [1, 0]
+                        [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 98ad89bee3556ed77680e812f6abc489ddf57305
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 01:00:02 2026 +0900

    fix(triangle): map specific row 6 tiles for T5, T6, T7 per user

diff --git a/script.js b/script.js
index 77bcdee..5487a55 100644
--- a/script.js
+++ b/script.js
@@ -2939,7 +2939,7 @@ class UnitessGalleryApp {
                         [0, 0],   // 24
                         [0, 240], // 25
                         // Row 6 additions
-                        [0, 240], [0, 120], [0, 0], [0, 120], [0, 120], [0, 0], [0, 240], [0, 120], [0, 0], [0, 120], [0, 120]
+                        [0, 240], [0, 240], [0, 0], [0, 120], [0, 120], [0, 0], [0, 240], [0, 240], [0, 0], [0, 120], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -2978,7 +2978,7 @@ class UnitessGalleryApp {
                         [0, 120], // 24 (I: (24)=3 -> Loc 120)
                         [0, 120], // 25 (I: (25)=3 -> Loc 120)
                         // Row 6 additions
-                        [0, 240], [0, 0], [0, 0], [0, 120], [0, 120], [0, 120], [0, 240], [0, 0], [0, 0], [0, 240], [0, 120]
+                        [0, 240], [0, 0], [0, 0], [0, 240], [0, 120], [0, 120], [0, 240], [0, 0], [0, 0], [0, 240], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -3017,7 +3017,7 @@ class UnitessGalleryApp {
                         [0, 240], // 24 (I: (24)=3. Both I so copy 240)
                         [0, 240], // 25
                         // Row 6 additions
-                        [0, 240], [0, 120], [0, 0], [0, 0], [0, 120], [0, 180], [0, 240], [0, 120], [0, 0], [0, 0], [0, 120]
+                        [0, 240], [0, 120], [0, 0], [0, 0], [0, 120], [0, 240], [0, 240], [0, 120], [0, 0], [0, 0], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit c725f92b97fcc9caf5725a3c65eebf6bc77ff7ef
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 00:52:59 2026 +0900

    fix(triangle): correct additional row 6 tiles for T6 and T7 based on user mapping

diff --git a/script.js b/script.js
index ecc44be..77bcdee 100644
--- a/script.js
+++ b/script.js
@@ -2978,7 +2978,7 @@ class UnitessGalleryApp {
                         [0, 120], // 24 (I: (24)=3 -> Loc 120)
                         [0, 120], // 25 (I: (25)=3 -> Loc 120)
                         // Row 6 additions
-                        [0, 240], [0, 240], [0, 0], [0, 120], [0, 120], [0, 120], [0, 240], [0, 0], [0, 0], [0, 120], [0, 120]
+                        [0, 240], [0, 0], [0, 0], [0, 120], [0, 120], [0, 120], [0, 240], [0, 0], [0, 0], [0, 240], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -3017,7 +3017,7 @@ class UnitessGalleryApp {
                         [0, 240], // 24 (I: (24)=3. Both I so copy 240)
                         [0, 240], // 25
                         // Row 6 additions
-                        [0, 240], [0, 120], [0, 0], [0, 0], [0, 120], [0, 180], [0, 240], [0, 240], [0, 0], [0, 0], [0, 120]
+                        [0, 240], [0, 120], [0, 0], [0, 0], [0, 120], [0, 180], [0, 240], [0, 120], [0, 0], [0, 0], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit be9f296cbf700edf2169873adbcf368684bc5e2a
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 00:44:38 2026 +0900

    fix(triangle): correct tiles 27, 29, 31, 35 in row 6 per user mapping for T5, T6, T7

diff --git a/script.js b/script.js
index 7984c87..ecc44be 100644
--- a/script.js
+++ b/script.js
@@ -2939,7 +2939,7 @@ class UnitessGalleryApp {
                         [0, 0],   // 24
                         [0, 240], // 25
                         // Row 6 additions
-                        [0, 240], [0, 120], [0, 0], [0, 240], [0, 120], [0, 0], [0, 240], [0, 120], [0, 0], [0, 240], [0, 120]
+                        [0, 240], [0, 120], [0, 0], [0, 120], [0, 120], [0, 0], [0, 240], [0, 120], [0, 0], [0, 120], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -2978,7 +2978,7 @@ class UnitessGalleryApp {
                         [0, 120], // 24 (I: (24)=3 -> Loc 120)
                         [0, 120], // 25 (I: (25)=3 -> Loc 120)
                         // Row 6 additions
-                        [0, 240], [0, 0], [0, 0], [0, 120], [0, 120], [0, 240], [0, 240], [0, 0], [0, 0], [0, 120], [0, 120]
+                        [0, 240], [0, 240], [0, 0], [0, 120], [0, 120], [0, 120], [0, 240], [0, 0], [0, 0], [0, 120], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -3017,7 +3017,7 @@ class UnitessGalleryApp {
                         [0, 240], // 24 (I: (24)=3. Both I so copy 240)
                         [0, 240], // 25
                         // Row 6 additions
-                        [0, 240], [0, 240], [0, 0], [0, 0], [0, 120], [0, 120], [0, 240], [0, 240], [0, 0], [0, 0], [0, 120]
+                        [0, 240], [0, 120], [0, 0], [0, 0], [0, 120], [0, 180], [0, 240], [0, 240], [0, 0], [0, 0], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 319e91c00ef17ed0ca2fbfdbd38694bbb131de90
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 00:32:01 2026 +0900

    feat(triangle): add explicit 6th row values for T2 through T7

diff --git a/script.js b/script.js
index 3988d46..7984c87 100644
--- a/script.js
+++ b/script.js
@@ -2858,7 +2858,9 @@ class UnitessGalleryApp {
                         [0, 0], [0, 0], [1, 120], [1, 120], [1, 120],
                         [0, 0], [0, 0], [1, 120], [1, 120], [0, 0],
                         [0, 0], [1, 120], [0, 0], [0, 0], [1, 120],
-                        [1, 120], [0, 0], [0, 0], [1, 120], [1, 120]
+                        [1, 120], [0, 0], [0, 0], [1, 120], [1, 120],
+                        // Row 6 additions
+                        [0, 0], [0, 0], [1, 120], [1, 120], [0, 0], [0, 0], [1, 120], [1, 120], [0, 0], [0, 0], [1, 120]
                     ];
                     // Manual Overrides requested previously:
                     // 1=(2,5,9,10,14) -> [1,120]. 14 is idx 13 (0-based)
@@ -2878,7 +2880,9 @@ class UnitessGalleryApp {
                         [1, 240], [0, 0], [0, 0], [1, 240], [0, 0],
                         [0, 0], [1, 240], [1, 240], [0, 0], [0, 0],
                         [1, 240], [1, 240], [1, 240], [0, 0], [0, 0],
-                        [1, 240], [1, 240], [0, 0], [0, 0], [1, 240]
+                        [1, 240], [1, 240], [0, 0], [0, 0], [1, 240],
+                        // Row 6 additions
+                        [0, 0], [0, 0], [1, 240], [1, 240], [0, 0], [0, 0], [1, 240], [1, 240], [0, 0], [0, 0], [1, 240]
                     ];
                     // Ensure manual mapping from user is kept (1,4,5,9,12,16=[1,240], 2,3,7,8,10,11,14,15=[0,0])
                     const state = table[tileIdx];
@@ -2895,7 +2899,9 @@ class UnitessGalleryApp {
                         [1, 0], [0, 0], [1, 0], [0, 0], [1, 0],
                         [0, 0], [1, 0], [0, 0], [1, 0], [0, 0],
                         [1, 0], [0, 0], [1, 0], [0, 0], [1, 0],
-                        [0, 0], [1, 0], [0, 0], [1, 0], [0, 0]
+                        [0, 0], [1, 0], [0, 0], [1, 0], [0, 0],
+                        // Row 6 additions
+                        [1, 0], [0, 0], [1, 0], [0, 0], [1, 0], [0, 0], [1, 0], [0, 0], [1, 0], [0, 0], [1, 0]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -2931,7 +2937,9 @@ class UnitessGalleryApp {
                         [0, 120], // 22 (Rotate 240 from 240 -> 120)
                         [0, 120], // 23
                         [0, 0],   // 24
-                        [0, 240]  // 25
+                        [0, 240], // 25
+                        // Row 6 additions
+                        [0, 240], [0, 120], [0, 0], [0, 240], [0, 120], [0, 0], [0, 240], [0, 120], [0, 0], [0, 240], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -2968,7 +2976,9 @@ class UnitessGalleryApp {
                         [0, 240], // 22 (I: (22)=5+180 -> Loc 240)
                         [0, 120], // 23
                         [0, 120], // 24 (I: (24)=3 -> Loc 120)
-                        [0, 120]  // 25 (I: (25)=3 -> Loc 120)
+                        [0, 120], // 25 (I: (25)=3 -> Loc 120)
+                        // Row 6 additions
+                        [0, 240], [0, 0], [0, 0], [0, 120], [0, 120], [0, 240], [0, 240], [0, 0], [0, 0], [0, 120], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {
@@ -3005,7 +3015,9 @@ class UnitessGalleryApp {
                         [0, 0],   // 22
                         [0, 120], // 23
                         [0, 240], // 24 (I: (24)=3. Both I so copy 240)
-                        [0, 240]  // 25
+                        [0, 240], // 25
+                        // Row 6 additions
+                        [0, 240], [0, 240], [0, 0], [0, 0], [0, 120], [0, 120], [0, 240], [0, 240], [0, 0], [0, 0], [0, 120]
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit bf2ea4d3b7c6a17bbcc4b9872ae32c91703ccba9
Author: galua2001 <galua2001@gmail.com>
Date:   Sun Feb 22 00:20:56 2026 +0900

    feat(triangle): expand pyramid to 6 rows (36 tiles) maintaining exact mathematical symmetry

diff --git a/script.js b/script.js
index 6379b92..3988d46 100644
--- a/script.js
+++ b/script.js
@@ -2696,7 +2696,7 @@ class UnitessGalleryApp {
             let idCounter = 1;
 
             if (type === 'triangle') {
-                const rows = 5; // Changed from 4 to 5
+                const rows = 6; // Changed from 5 to 6
                 const totalW = w * 0.95;
                 const size = totalW / rows;
                 const triH = size * Math.sqrt(3) / 2;
@@ -2842,7 +2842,7 @@ class UnitessGalleryApp {
             switch (patternId) {
                 case 1: { // T1 = CCC: Basic translation (only C transformations, pure rotations that look the same on inverted)
                     // Expanded to 25 tiles (5 rows)
-                    const table = Array(25).fill([0, 0]);
+                    const table = Array(36).fill([0, 0]);
                     const state = table[tileIdx];
                     if (state) {
                         ctx.scale(state[0] ? -1 : 1, 1);

commit c18efdd5471d6de445242cf30d0433b1a0f53068
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:24:59 2026 +0900

    fix(triangle): copy tile 3 to 18, 13, 24 and tile 6 to 15, 20 directly for CC6C6(2) per latest matching

diff --git a/script.js b/script.js
index 4c2c3ef..6379b92 100644
--- a/script.js
+++ b/script.js
@@ -2993,18 +2993,18 @@ class UnitessGalleryApp {
                         [0, 0],   // 10
                         [0, 0],   // 11
                         [0, 120], // 12
-                        [0, 300], // 13 (I: (13)=2. Tile 2 is U(120), so I needs 120+180=300)
+                        [0, 240], // 13 (I: (13)=3. Both I so copy 240)
                         [0, 240], // 14
-                        [0, 240], // 15
+                        [0, 120], // 15 (I: (15)=6. Both I so copy 120)
                         [0, 0],   // 16
                         [0, 120], // 17
-                        [0, 300], // 18 (I: (18)=2. Tile 2 is U(120), so I needs 120+180=300)
+                        [0, 240], // 18 (I: (18)=3. Both I so copy 240)
                         [0, 240], // 19
-                        [0, 0],   // 20 (I: (20)=8. Tile 8 is I(0), copy directly)
+                        [0, 120], // 20 (I: (20)=6. Both I so copy 120)
                         [0, 0],   // 21
                         [0, 0],   // 22
                         [0, 120], // 23
-                        [0, 300], // 24 (I: (24)=2. Tile 2 is U(120), so I needs 120+180=300)
+                        [0, 240], // 24 (I: (24)=3. Both I so copy 240)
                         [0, 240]  // 25
                     ];
                     const state = table[tileIdx];

commit 7ad6034143cd746b811da7d7c513f569702dbcb2
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:21:12 2026 +0900

    fix(triangle): copy tile 18, 13, 24 = 2 (incorporating inverted +180 since 2 is upright) and 20 = 8 (direct copy)

diff --git a/script.js b/script.js
index b36a8d1..4c2c3ef 100644
--- a/script.js
+++ b/script.js
@@ -2982,29 +2982,29 @@ class UnitessGalleryApp {
                     // Mathematically generated with E2=180, E1=60, E3=-60
                     const table = [
                         [0, 0],   // 1
-                        [0, 120], // 2
+                        [0, 120], // 2  (U: Vis 120)
                         [0, 240], // 3  (I: (3)=15 -> Loc 240)
                         [0, 240], // 4
                         [0, 240], // 5
                         [0, 120], // 6  (I: (6)=13 -> Loc 120)
-                        [0, 0],   // 7 (Base "aa")
-                        [0, 0],   // 8
+                        [0, 0],   // 7  (Base "aa")
+                        [0, 0],   // 8  (I: Loc 0)
                         [0, 120], // 9
                         [0, 0],   // 10
                         [0, 0],   // 11
                         [0, 120], // 12
-                        [0, 120], // 13
+                        [0, 300], // 13 (I: (13)=2. Tile 2 is U(120), so I needs 120+180=300)
                         [0, 240], // 14
                         [0, 240], // 15
                         [0, 0],   // 16
                         [0, 120], // 17
-                        [0, 120], // 18
+                        [0, 300], // 18 (I: (18)=2. Tile 2 is U(120), so I needs 120+180=300)
                         [0, 240], // 19
-                        [0, 240], // 20
+                        [0, 0],   // 20 (I: (20)=8. Tile 8 is I(0), copy directly)
                         [0, 0],   // 21
                         [0, 0],   // 22
                         [0, 120], // 23
-                        [0, 120], // 24
+                        [0, 300], // 24 (I: (24)=2. Tile 2 is U(120), so I needs 120+180=300)
                         [0, 240]  // 25
                     ];
                     const state = table[tileIdx];

commit d2be16a53f198a117a6ec28fdb12135c4596ebfa
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:18:03 2026 +0900

    fix(triangle): copy tile 3 -> 15 and tile 6 -> 13 for CC6C6(2)

diff --git a/script.js b/script.js
index d6199ac..b36a8d1 100644
--- a/script.js
+++ b/script.js
@@ -2983,10 +2983,10 @@ class UnitessGalleryApp {
                     const table = [
                         [0, 0],   // 1
                         [0, 120], // 2
-                        [0, 120], // 3
+                        [0, 240], // 3  (I: (3)=15 -> Loc 240)
                         [0, 240], // 4
                         [0, 240], // 5
-                        [0, 240], // 6
+                        [0, 120], // 6  (I: (6)=13 -> Loc 120)
                         [0, 0],   // 7 (Base "aa")
                         [0, 0],   // 8
                         [0, 120], // 9

commit 768ce358d78a11d38b38ba7872a7d11e47d210dc
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:14:28 2026 +0900

    feat(triangle): layout CC6C6(2) base template based on edge 2=180 rotation logically

diff --git a/script.js b/script.js
index 254cbb6..d6199ac 100644
--- a/script.js
+++ b/script.js
@@ -2977,9 +2977,43 @@ class UnitessGalleryApp {
                     }
                     break;
                 }
-                case 7: // T7 = CC6C6(2): Mirrored Grid (Upright=Mirrored F, Inverted=Upside down ??
-                    ctx.scale(-1, 1);
+                case 7: { // T7 = CC6C6(2)
+                    // Rule from user: 2踰덉뿉??180???뚯쟾
+                    // Mathematically generated with E2=180, E1=60, E3=-60
+                    const table = [
+                        [0, 0],   // 1
+                        [0, 120], // 2
+                        [0, 120], // 3
+                        [0, 240], // 4
+                        [0, 240], // 5
+                        [0, 240], // 6
+                        [0, 0],   // 7 (Base "aa")
+                        [0, 0],   // 8
+                        [0, 120], // 9
+                        [0, 0],   // 10
+                        [0, 0],   // 11
+                        [0, 120], // 12
+                        [0, 120], // 13
+                        [0, 240], // 14
+                        [0, 240], // 15
+                        [0, 0],   // 16
+                        [0, 120], // 17
+                        [0, 120], // 18
+                        [0, 240], // 19
+                        [0, 240], // 20
+                        [0, 0],   // 21
+                        [0, 0],   // 22
+                        [0, 120], // 23
+                        [0, 120], // 24
+                        [0, 240]  // 25
+                    ];
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
+                }
             }
         } else {
             // Hexagon Patterns (H1-H22)

commit 680f20c778a289e47ac8332b31f09978efc4a11d
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:10:53 2026 +0900

    fix(triangle): copy tile 24 = tile 3 for CC6C6(1)

diff --git a/script.js b/script.js
index f011b31..254cbb6 100644
--- a/script.js
+++ b/script.js
@@ -2967,7 +2967,7 @@ class UnitessGalleryApp {
                         [0, 0],   // 21
                         [0, 240], // 22 (I: (22)=5+180 -> Loc 240)
                         [0, 120], // 23
-                        [0, 0],   // 24 (I: Vis 180 -> Loc 0)
+                        [0, 120], // 24 (I: (24)=3 -> Loc 120)
                         [0, 120]  // 25 (I: (25)=3 -> Loc 120)
                     ];
                     const state = table[tileIdx];

commit 4ff14ee3ac3c53b808ee79c85eb7a1967bd99317
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:08:13 2026 +0900

    fix(triangle): map 8, 11, 22 to match tile 5 rotated by 180 degrees visually for CC6C6(1)

diff --git a/script.js b/script.js
index 0279ffc..f011b31 100644
--- a/script.js
+++ b/script.js
@@ -2951,10 +2951,10 @@ class UnitessGalleryApp {
                         [0, 240], // 5
                         [0, 0],   // 6  (I: (6)=20 -> Loc 0)
                         [0, 0],   // 7  (Base "aa")
-                        [0, 120], // 8
+                        [0, 240], // 8  (I: (8)=5+180 -> Loc 240)
                         [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 300], // 11 (I: (11)=23. 23 is U(Vis 120), so 11 needs Vis 120 -> Loc 300)
+                        [0, 240], // 11 (I: (11)=5+180 -> Loc 240)
                         [0, 120], // 12
                         [0, 120], // 13 (I: (13)=3 -> Loc 120)
                         [0, 240], // 14
@@ -2965,7 +2965,7 @@ class UnitessGalleryApp {
                         [0, 240], // 19
                         [0, 0],   // 20
                         [0, 0],   // 21
-                        [0, 60],  // 22 (I: Vis 240 -> Loc 60)
+                        [0, 240], // 22 (I: (22)=5+180 -> Loc 240)
                         [0, 120], // 23
                         [0, 0],   // 24 (I: Vis 180 -> Loc 0)
                         [0, 120]  // 25 (I: (25)=3 -> Loc 120)

commit 8e0a32058ed76a9b633768ecfa9c3b3f326d8135
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:04:35 2026 +0900

    fix(triangle): copy tile 3 -> 13, 25 for CC6C6(1) with exact inverse mapping

diff --git a/script.js b/script.js
index 571fd02..0279ffc 100644
--- a/script.js
+++ b/script.js
@@ -2956,7 +2956,7 @@ class UnitessGalleryApp {
                         [0, 0],   // 10
                         [0, 300], // 11 (I: (11)=23. 23 is U(Vis 120), so 11 needs Vis 120 -> Loc 300)
                         [0, 120], // 12
-                        [0, 0],   // 13 (I: (13)=20 -> Loc 0)
+                        [0, 120], // 13 (I: (13)=3 -> Loc 120)
                         [0, 240], // 14
                         [0, 0],   // 15 (I: (15)=20 -> Loc 0)
                         [0, 0],   // 16
@@ -2968,7 +2968,7 @@ class UnitessGalleryApp {
                         [0, 60],  // 22 (I: Vis 240 -> Loc 60)
                         [0, 120], // 23
                         [0, 0],   // 24 (I: Vis 180 -> Loc 0)
-                        [0, 240]  // 25
+                        [0, 120]  // 25 (I: (25)=3 -> Loc 120)
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 69f494abb69f2a02403217a50aa286c0c26d46e7
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 22:00:15 2026 +0900

    fix(triangle): copy tile states 6,15=20, 11=23, 18=3, 13=20 mapped for CC6C6(1) considering grid inversion where required

diff --git a/script.js b/script.js
index 03cae63..571fd02 100644
--- a/script.js
+++ b/script.js
@@ -2949,19 +2949,19 @@ class UnitessGalleryApp {
                         [0, 120], // 3  (I: (3)=11 -> Loc 120)
                         [0, 240], // 4
                         [0, 240], // 5
-                        [0, 60],  // 6  (I: Vis 240 -> Loc 60)
+                        [0, 0],   // 6  (I: (6)=20 -> Loc 0)
                         [0, 0],   // 7  (Base "aa")
                         [0, 120], // 8
                         [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 120], // 11
+                        [0, 300], // 11 (I: (11)=23. 23 is U(Vis 120), so 11 needs Vis 120 -> Loc 300)
                         [0, 120], // 12
-                        [0, 0],   // 13 (I: Vis 180 -> Loc 0)
+                        [0, 0],   // 13 (I: (13)=20 -> Loc 0)
                         [0, 240], // 14
-                        [0, 60],  // 15 (I: Vis 240 -> Loc 60)
+                        [0, 0],   // 15 (I: (15)=20 -> Loc 0)
                         [0, 0],   // 16
                         [0, 120], // 17
-                        [0, 0],   // 18 (I: Vis 180 -> Loc 0)
+                        [0, 120], // 18 (I: (18)=3 -> Loc 120)
                         [0, 240], // 19
                         [0, 0],   // 20
                         [0, 0],   // 21

commit 449ded285b43ba4c0700bae3b6ceab4c0031b1cc
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:51:30 2026 +0900

    fix(triangle): set tile 3 to match tile 11 exactly for CC6C6(1)

diff --git a/script.js b/script.js
index dc2d4f3..03cae63 100644
--- a/script.js
+++ b/script.js
@@ -2946,7 +2946,7 @@ class UnitessGalleryApp {
                     const table = [
                         [0, 0],   // 1
                         [0, 120], // 2
-                        [0, 60],  // 3  (I: Vis 240 -> Loc 60)
+                        [0, 120], // 3  (I: (3)=11 -> Loc 120)
                         [0, 240], // 4
                         [0, 240], // 5
                         [0, 60],  // 6  (I: Vis 240 -> Loc 60)

commit f26c91ce8a0220c53e2bd8fefe8b431fac5ba610
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:47:49 2026 +0900

    fix(triangle): correct inverted offset parsing for CC6C6(1) copy targets

diff --git a/script.js b/script.js
index f4cc912..dc2d4f3 100644
--- a/script.js
+++ b/script.js
@@ -2946,28 +2946,28 @@ class UnitessGalleryApp {
                     const table = [
                         [0, 0],   // 1
                         [0, 120], // 2
-                        [0, 240], // 3  (U: (3)=19 -> 240)
+                        [0, 60],  // 3  (I: Vis 240 -> Loc 60)
                         [0, 240], // 4
                         [0, 240], // 5
-                        [0, 240], // 6  (U: (6)=3 -> 240)
-                        [0, 0],   // 7 (Base "aa")
+                        [0, 60],  // 6  (I: Vis 240 -> Loc 60)
+                        [0, 0],   // 7  (Base "aa")
                         [0, 120], // 8
                         [0, 120], // 9
                         [0, 0],   // 10
                         [0, 120], // 11
                         [0, 120], // 12
-                        [0, 0],   // 13 (U: (13)=20 -> 0)
+                        [0, 0],   // 13 (I: Vis 180 -> Loc 0)
                         [0, 240], // 14
-                        [0, 240], // 15 (U: (15)=3 -> 240)
+                        [0, 60],  // 15 (I: Vis 240 -> Loc 60)
                         [0, 0],   // 16
                         [0, 120], // 17
-                        [0, 0],   // 18 (U: (18)=20 -> 0)
+                        [0, 0],   // 18 (I: Vis 180 -> Loc 0)
                         [0, 240], // 19
                         [0, 0],   // 20
                         [0, 0],   // 21
-                        [0, 240], // 22 (U: (22)=3 -> 240)
+                        [0, 60],  // 22 (I: Vis 240 -> Loc 60)
                         [0, 120], // 23
-                        [0, 0],   // 24 (U: (24)=18 -> 0)
+                        [0, 0],   // 24 (I: Vis 180 -> Loc 0)
                         [0, 240]  // 25
                     ];
                     const state = table[tileIdx];

commit 1d6f53449e084cda560204d7005a6bae287a40da
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:43:35 2026 +0900

    fix(triangle): manually copy values for tiles 3, 6, 13, 15, 18, 22, 24 as requested for CC6C6(1)

diff --git a/script.js b/script.js
index d4c0b3c..f4cc912 100644
--- a/script.js
+++ b/script.js
@@ -2946,28 +2946,28 @@ class UnitessGalleryApp {
                     const table = [
                         [0, 0],   // 1
                         [0, 120], // 2
-                        [0, 240], // 3
+                        [0, 240], // 3  (U: (3)=19 -> 240)
                         [0, 240], // 4
                         [0, 240], // 5
-                        [0, 0],   // 6
+                        [0, 240], // 6  (U: (6)=3 -> 240)
                         [0, 0],   // 7 (Base "aa")
                         [0, 120], // 8
                         [0, 120], // 9
                         [0, 0],   // 10
                         [0, 120], // 11
                         [0, 120], // 12
-                        [0, 240], // 13
+                        [0, 0],   // 13 (U: (13)=20 -> 0)
                         [0, 240], // 14
-                        [0, 0],   // 15
+                        [0, 240], // 15 (U: (15)=3 -> 240)
                         [0, 0],   // 16
                         [0, 120], // 17
-                        [0, 240], // 18
+                        [0, 0],   // 18 (U: (18)=20 -> 0)
                         [0, 240], // 19
                         [0, 0],   // 20
                         [0, 0],   // 21
-                        [0, 120], // 22
+                        [0, 240], // 22 (U: (22)=3 -> 240)
                         [0, 120], // 23
-                        [0, 240], // 24
+                        [0, 0],   // 24 (U: (24)=18 -> 0)
                         [0, 240]  // 25
                     ];
                     const state = table[tileIdx];

commit e7d2fa4ee71dfe9a9fa7a36b7b418f20090585de
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:36:07 2026 +0900

    feat(triangle): implement CC6C6(1) using edge 1=180, edge 2=300, edge 3=60 rotation logic

diff --git a/script.js b/script.js
index 35efbfb..d4c0b3c 100644
--- a/script.js
+++ b/script.js
@@ -2940,9 +2940,43 @@ class UnitessGalleryApp {
                     }
                     break;
                 }
-                case 6: // T6 = CC6C6(1): Natural Grid (Upright=F, Inverted=Upside down F)
-                    // Identity
+                case 6: { // T6 = CC6C6(1)
+                    // Rule from user: 1踰덉뿉?쒕쭔 180???뚯쟾, ?ㅻⅨ 怨녹? 60, -60 ?뚯쟾
+                    // Base `aa` is tile 7 (index 6).
+                    const table = [
+                        [0, 0],   // 1
+                        [0, 120], // 2
+                        [0, 240], // 3
+                        [0, 240], // 4
+                        [0, 240], // 5
+                        [0, 0],   // 6
+                        [0, 0],   // 7 (Base "aa")
+                        [0, 120], // 8
+                        [0, 120], // 9
+                        [0, 0],   // 10
+                        [0, 120], // 11
+                        [0, 120], // 12
+                        [0, 240], // 13
+                        [0, 240], // 14
+                        [0, 0],   // 15
+                        [0, 0],   // 16
+                        [0, 120], // 17
+                        [0, 240], // 18
+                        [0, 240], // 19
+                        [0, 0],   // 20
+                        [0, 0],   // 21
+                        [0, 120], // 22
+                        [0, 120], // 23
+                        [0, 240], // 24
+                        [0, 240]  // 25
+                    ];
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
+                }
                 case 7: // T7 = CC6C6(2): Mirrored Grid (Upright=Mirrored F, Inverted=Upside down ??
                     ctx.scale(-1, 1);
                     break;

commit 68dd331d1d35f874f79fc43fe079e0a25c924b5d
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:28:31 2026 +0900

    fix(triangle): rotate tiles 8, 11, 22 by exactly 240 degrees from their current states

diff --git a/script.js b/script.js
index 209c89a..35efbfb 100644
--- a/script.js
+++ b/script.js
@@ -2914,10 +2914,10 @@ class UnitessGalleryApp {
                         [0, 240], // 5
                         [0, 240], // 6  (User: 240)
                         [0, 0],   // 7  (Base "aa")
-                        [0, 240], // 8  (I: Vis 60 -> Loc 240)
+                        [0, 120], // 8  (Rotate 240 from 240 -> 120)
                         [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 240], // 11 (I: Vis 60 -> Loc 240)
+                        [0, 120], // 11 (Rotate 240 from 240 -> 120)
                         [0, 120], // 12
                         [0, 0],   // 13
                         [0, 240], // 14
@@ -2928,7 +2928,7 @@ class UnitessGalleryApp {
                         [0, 240], // 19
                         [0, 240], // 20 (I: (20)=(6) -> Loc 240)
                         [0, 0],   // 21
-                        [0, 240], // 22 (I: Vis 60 -> Loc 240)
+                        [0, 120], // 22 (Rotate 240 from 240 -> 120)
                         [0, 120], // 23
                         [0, 0],   // 24
                         [0, 240]  // 25

commit 23cd86d59419b9607bef1bb944f8a3da84b6a91d
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:22:38 2026 +0900

    fix(triangle): rigidly apply user's explicit copying mappings (15,20)=(6) and retain 240 for 8, 11, 22

diff --git a/script.js b/script.js
index 38f665d..209c89a 100644
--- a/script.js
+++ b/script.js
@@ -2910,25 +2910,25 @@ class UnitessGalleryApp {
                         [0, 0],   // 1
                         [0, 120], // 2
                         [0, 0],   // 3
-                        [0, 240], // 4  (U: (4)=19 -> Loc 240)
-                        [0, 240], // 5  (U: Vis 240 -> Loc 240)
-                        [0, 240], // 6  (I: (6)=22 -> Loc 240)
+                        [0, 240], // 4
+                        [0, 240], // 5
+                        [0, 240], // 6  (User: 240)
                         [0, 0],   // 7  (Base "aa")
-                        [0, 240], // 8  (I: (8)=6 -> Loc 240)
+                        [0, 240], // 8  (I: Vis 60 -> Loc 240)
                         [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 240], // 11 (I: (11)=6 -> Loc 240)
+                        [0, 240], // 11 (I: Vis 60 -> Loc 240)
                         [0, 120], // 12
                         [0, 0],   // 13
-                        [0, 240], // 14 (U: (14)=19 -> Loc 240)
-                        [0, 60],  // 15 (I: Vis 240 -> Loc 60)
+                        [0, 240], // 14
+                        [0, 240], // 15 (I: (15)=(6) -> Loc 240)
                         [0, 0],   // 16
                         [0, 120], // 17
                         [0, 0],   // 18
-                        [0, 240], // 19 (U: Base reference)
-                        [0, 60],  // 20 (I: Vis 240 -> Loc 60)
+                        [0, 240], // 19
+                        [0, 240], // 20 (I: (20)=(6) -> Loc 240)
                         [0, 0],   // 21
-                        [0, 240], // 22 (I: Base reference)
+                        [0, 240], // 22 (I: Vis 60 -> Loc 240)
                         [0, 120], // 23
                         [0, 0],   // 24
                         [0, 240]  // 25

commit c164f23ef0378d6f0a280390634915928deb57c3
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:15:21 2026 +0900

    fix(triangle): rigidly apply user's explicit copying mappings (4,14)=(19) and (6)=(22) and (8,11)=(6)

diff --git a/script.js b/script.js
index a66dd3c..38f665d 100644
--- a/script.js
+++ b/script.js
@@ -2910,25 +2910,25 @@ class UnitessGalleryApp {
                         [0, 0],   // 1
                         [0, 120], // 2
                         [0, 0],   // 3
-                        [0, 120], // 4  (U: Vis 120 -> Loc 120)
+                        [0, 240], // 4  (U: (4)=19 -> Loc 240)
                         [0, 240], // 5  (U: Vis 240 -> Loc 240)
-                        [0, 120], // 6
+                        [0, 240], // 6  (I: (6)=22 -> Loc 240)
                         [0, 0],   // 7  (Base "aa")
-                        [0, 240], // 8  (I: Vis 60 -> Loc 240)
+                        [0, 240], // 8  (I: (8)=6 -> Loc 240)
                         [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 240], // 11 (I: Vis 60 -> Loc 240)
+                        [0, 240], // 11 (I: (11)=6 -> Loc 240)
                         [0, 120], // 12
                         [0, 0],   // 13
-                        [0, 120], // 14 (U: Vis 120 -> Loc 120)
+                        [0, 240], // 14 (U: (14)=19 -> Loc 240)
                         [0, 60],  // 15 (I: Vis 240 -> Loc 60)
                         [0, 0],   // 16
                         [0, 120], // 17
                         [0, 0],   // 18
-                        [0, 240], // 19
+                        [0, 240], // 19 (U: Base reference)
                         [0, 60],  // 20 (I: Vis 240 -> Loc 60)
                         [0, 0],   // 21
-                        [0, 240], // 22 (I: Vis 60 -> Loc 240)
+                        [0, 240], // 22 (I: Base reference)
                         [0, 120], // 23
                         [0, 0],   // 24
                         [0, 240]  // 25

commit d131218d6f8c762060e76a6620258a4502ef8db8
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 21:05:25 2026 +0900

    fix(triangle): strictly apply manually provided angles only to user specified tiles 4,5,8,11,14,15,20,22 WITH inverted offset

diff --git a/script.js b/script.js
index 56c61dc..a66dd3c 100644
--- a/script.js
+++ b/script.js
@@ -2910,25 +2910,25 @@ class UnitessGalleryApp {
                         [0, 0],   // 1
                         [0, 120], // 2
                         [0, 0],   // 3
-                        [0, 120], // 4  (?섏젙 ?꾨즺: ?쒓컖 120)
-                        [0, 240], // 5
+                        [0, 120], // 4  (U: Vis 120 -> Loc 120)
+                        [0, 240], // 5  (U: Vis 240 -> Loc 240)
                         [0, 120], // 6
                         [0, 0],   // 7  (Base "aa")
-                        [0, 240], // 8  (?섏젙 ?꾨즺: ??궪媛곹삎 ?쒓컖 60)
+                        [0, 240], // 8  (I: Vis 60 -> Loc 240)
                         [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 240], // 11
+                        [0, 240], // 11 (I: Vis 60 -> Loc 240)
                         [0, 120], // 12
                         [0, 0],   // 13
-                        [0, 120], // 14 (?섏젙 ?꾨즺: ?쒓컖 120)
-                        [0, 120], // 15
+                        [0, 120], // 14 (U: Vis 120 -> Loc 120)
+                        [0, 60],  // 15 (I: Vis 240 -> Loc 60)
                         [0, 0],   // 16
                         [0, 120], // 17
                         [0, 0],   // 18
                         [0, 240], // 19
-                        [0, 120], // 20
+                        [0, 60],  // 20 (I: Vis 240 -> Loc 60)
                         [0, 0],   // 21
-                        [0, 240], // 22 (?섏젙 ?꾨즺: ??궪媛곹삎 ?쒓컖 60)
+                        [0, 240], // 22 (I: Vis 60 -> Loc 240)
                         [0, 120], // 23
                         [0, 0],   // 24
                         [0, 240]  // 25

commit d1eeaefe45894be5910c8eab4b994102a721a4f4
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:59:23 2026 +0900

    fix(triangle): strictly apply manually provided angles only to user specified tiles 4,8,14,22

diff --git a/script.js b/script.js
index ce64c6b..56c61dc 100644
--- a/script.js
+++ b/script.js
@@ -2910,25 +2910,25 @@ class UnitessGalleryApp {
                         [0, 0],   // 1
                         [0, 120], // 2
                         [0, 0],   // 3
-                        [0, 120], // 4  (U: Loc = Vis 120)
+                        [0, 120], // 4  (?섏젙 ?꾨즺: ?쒓컖 120)
                         [0, 240], // 5
-                        [0, 60],  // 6  (I: Loc = Vis 240 + 180 = 60)
+                        [0, 120], // 6
                         [0, 0],   // 7  (Base "aa")
-                        [0, 240], // 8  (I: Loc = Vis 60 + 180 = 240)
+                        [0, 240], // 8  (?섏젙 ?꾨즺: ??궪媛곹삎 ?쒓컖 60)
                         [0, 120], // 9
                         [0, 0],   // 10
                         [0, 240], // 11
                         [0, 120], // 12
                         [0, 0],   // 13
-                        [0, 120], // 14 (U: Loc = Vis 120)
-                        [0, 60],  // 15 (I: Loc = Vis 240 + 180 = 60)
+                        [0, 120], // 14 (?섏젙 ?꾨즺: ?쒓컖 120)
+                        [0, 120], // 15
                         [0, 0],   // 16
                         [0, 120], // 17
                         [0, 0],   // 18
                         [0, 240], // 19
-                        [0, 60],  // 20 (I: Loc = Vis 240 + 180 = 60)
-                        [0, 0],   // 21 (U: Loc = Vis 0)
-                        [0, 240], // 22 (I: Loc = Vis 60 + 180 = 240)
+                        [0, 120], // 20
+                        [0, 0],   // 21
+                        [0, 240], // 22 (?섏젙 ?꾨즺: ??궪媛곹삎 ?쒓컖 60)
                         [0, 120], // 23
                         [0, 0],   // 24
                         [0, 240]  // 25

commit e51fbdcabe9e275ef9be53caecf92c0b9937cce2
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:55:29 2026 +0900

    fix(triangle): map all explicitly given visual angles to correct local angles considering inverted rendering +180 addition

diff --git a/script.js b/script.js
index 6a99ab9..ce64c6b 100644
--- a/script.js
+++ b/script.js
@@ -2905,31 +2905,30 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // Exact strict logic: "3踰?Bottom)?먯꽌留?180???뚯쟾?대떎!" + "1, 2 諛⑺뼢? +60, -60?대떎!" + "紐⑤뱺 ?쇨컖??二쇰?? 180???뚯쟾?섏뼱 ?덈떎!"
-                    // 'aa' (Tile 7) is Upright, visual 0 -> Local 0
+                    // User manually dictating values:
                     const table = [
                         [0, 0],   // 1
                         [0, 120], // 2
                         [0, 0],   // 3
-                        [0, 240], // 4
+                        [0, 120], // 4  (U: Loc = Vis 120)
                         [0, 240], // 5
-                        [0, 120], // 6
-                        [0, 0],   // 7 (Base "aa")
-                        [0, 240], // 8 
+                        [0, 60],  // 6  (I: Loc = Vis 240 + 180 = 60)
+                        [0, 0],   // 7  (Base "aa")
+                        [0, 240], // 8  (I: Loc = Vis 60 + 180 = 240)
                         [0, 120], // 9
                         [0, 0],   // 10
                         [0, 240], // 11
                         [0, 120], // 12
-                        [0, 0],   // 13 (Base "aa" via 3踰?
-                        [0, 240], // 14
-                        [0, 120], // 15
+                        [0, 0],   // 13
+                        [0, 120], // 14 (U: Loc = Vis 120)
+                        [0, 60],  // 15 (I: Loc = Vis 240 + 180 = 60)
                         [0, 0],   // 16
                         [0, 120], // 17
                         [0, 0],   // 18
                         [0, 240], // 19
-                        [0, 120], // 20
-                        [0, 0],   // 21
-                        [0, 240], // 22
+                        [0, 60],  // 20 (I: Loc = Vis 240 + 180 = 60)
+                        [0, 0],   // 21 (U: Loc = Vis 0)
+                        [0, 240], // 22 (I: Loc = Vis 60 + 180 = 240)
                         [0, 120], // 23
                         [0, 0],   // 24
                         [0, 240]  // 25

commit 7e592dfe31b174e0c80c433f68a07884ecac5ce8
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:29:04 2026 +0900

    fix(triangle): correct index shift error in CC6C6 mapping to align aa with tile 7 exactly

diff --git a/script.js b/script.js
index 508d976..6a99ab9 100644
--- a/script.js
+++ b/script.js
@@ -2907,35 +2907,32 @@ class UnitessGalleryApp {
                 case 5: { // T5 = CC6C6
                     // Exact strict logic: "3踰?Bottom)?먯꽌留?180???뚯쟾?대떎!" + "1, 2 諛⑺뼢? +60, -60?대떎!" + "紐⑤뱺 ?쇨컖??二쇰?? 180???뚯쟾?섏뼱 ?덈떎!"
                     // 'aa' (Tile 7) is Upright, visual 0 -> Local 0
-                    // Crossing Edge 3 (Bottom): 180 visual rotation. Grid is inverted (180), Local = 180-180 = 0.
-                    // Crossing Edge 2 (Right): +60 visual rotation. Grid is inverted (180), Local = 60-180 = -120 = 240.
-                    // Crossing Edge 1 (Left): -60 (300) visual rotation. Grid inverted (180), Local = 300-180 = 120.
                     const table = [
-                        [0, 120], // 1
-                        [0, 0],   // 2
-                        [0, 240], // 3
+                        [0, 0],   // 1
+                        [0, 120], // 2
+                        [0, 0],   // 3
                         [0, 240], // 4
-                        [0, 120], // 5
-                        [0, 0],   // 6
-                        [0, 240], // 7
-                        [0, 120], // 8 
-                        [0, 0],   // 9
-                        [0, 240], // 10
-                        [0, 120], // 11
-                        [0, 0],   // 12
-                        [0, 240], // 13
-                        [0, 120], // 14
-                        [0, 0],   // 15
-                        [0, 120], // 16
-                        [0, 0],   // 17
-                        [0, 240], // 18
-                        [0, 120], // 19
-                        [0, 0],   // 20
-                        [0, 240], // 21
-                        [0, 120], // 22
-                        [0, 0],   // 23
-                        [0, 240], // 24
-                        [0, 120]  // 25
+                        [0, 240], // 5
+                        [0, 120], // 6
+                        [0, 0],   // 7 (Base "aa")
+                        [0, 240], // 8 
+                        [0, 120], // 9
+                        [0, 0],   // 10
+                        [0, 240], // 11
+                        [0, 120], // 12
+                        [0, 0],   // 13 (Base "aa" via 3踰?
+                        [0, 240], // 14
+                        [0, 120], // 15
+                        [0, 0],   // 16
+                        [0, 120], // 17
+                        [0, 0],   // 18
+                        [0, 240], // 19
+                        [0, 120], // 20
+                        [0, 0],   // 21
+                        [0, 240], // 22
+                        [0, 120], // 23
+                        [0, 0],   // 24
+                        [0, 240]  // 25
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 4763b62c44995889c9ac6be48c6f91cdaca2efbd
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:25:19 2026 +0900

    fix(triangle): correct cc6c6 array enforcing 180 only across edge 3

diff --git a/script.js b/script.js
index 8953752..508d976 100644
--- a/script.js
+++ b/script.js
@@ -2905,37 +2905,37 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // Exact logic matching user's diagram with +60 clockwise right progression:
+                    // Exact strict logic: "3踰?Bottom)?먯꽌留?180???뚯쟾?대떎!" + "1, 2 諛⑺뼢? +60, -60?대떎!" + "紐⑤뱺 ?쇨컖??二쇰?? 180???뚯쟾?섏뼱 ?덈떎!"
                     // 'aa' (Tile 7) is Upright, visual 0 -> Local 0
                     // Crossing Edge 3 (Bottom): 180 visual rotation. Grid is inverted (180), Local = 180-180 = 0.
                     // Crossing Edge 2 (Right): +60 visual rotation. Grid is inverted (180), Local = 60-180 = -120 = 240.
                     // Crossing Edge 1 (Left): -60 (300) visual rotation. Grid inverted (180), Local = 300-180 = 120.
                     const table = [
-                        [0, 0],   // 1
-                        [0, 120], // 2
-                        [0, 0],   // 3
+                        [0, 120], // 1
+                        [0, 0],   // 2
+                        [0, 240], // 3
                         [0, 240], // 4
-                        [0, 240], // 5
-                        [0, 120], // 6
-                        [0, 0],   // 7
-                        [0, 240], // 8 
-                        [0, 120], // 9
-                        [0, 0],   // 10
-                        [0, 240], // 11
-                        [0, 120], // 12
-                        [0, 0],   // 13
-                        [0, 240], // 14
-                        [0, 120], // 15
-                        [0, 0],   // 16
-                        [0, 120], // 17
-                        [0, 0],   // 18
-                        [0, 240], // 19
-                        [0, 120], // 20
-                        [0, 0],   // 21
-                        [0, 240], // 22
-                        [0, 120], // 23
-                        [0, 0],   // 24
-                        [0, 240]  // 25
+                        [0, 120], // 5
+                        [0, 0],   // 6
+                        [0, 240], // 7
+                        [0, 120], // 8 
+                        [0, 0],   // 9
+                        [0, 240], // 10
+                        [0, 120], // 11
+                        [0, 0],   // 12
+                        [0, 240], // 13
+                        [0, 120], // 14
+                        [0, 0],   // 15
+                        [0, 120], // 16
+                        [0, 0],   // 17
+                        [0, 240], // 18
+                        [0, 120], // 19
+                        [0, 0],   // 20
+                        [0, 240], // 21
+                        [0, 120], // 22
+                        [0, 0],   // 23
+                        [0, 240], // 24
+                        [0, 120]  // 25
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 7535ec4e9fd643399573131b49cd1cdaa556cc61
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:17:17 2026 +0900

    fix(triangle): correct cc6c6 mathematical visual array using proper CW 60 degree and 180 bottom edge rules

diff --git a/script.js b/script.js
index aa8c761..8953752 100644
--- a/script.js
+++ b/script.js
@@ -2905,37 +2905,37 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // Reversing rotation mapping and ensuring bottom edge is exactly 180 visual (local 0)
-                    // - Base (Tile 7): Upright, Visual 0 -> Local 0
-                    // - Bottom Edge (3踰?: 180 Visual -> Grid is inverted (180), so Local = 180 - 180 = 0
-                    // - Right Edge (2踰?: -60 (300) Visual -> Local = 300 - 180 = 120
-                    // - Left Edge (1踰?: +60 Visual -> Local = 60 - 180 = -120 = 240
+                    // Exact logic matching user's diagram with +60 clockwise right progression:
+                    // 'aa' (Tile 7) is Upright, visual 0 -> Local 0
+                    // Crossing Edge 3 (Bottom): 180 visual rotation. Grid is inverted (180), Local = 180-180 = 0.
+                    // Crossing Edge 2 (Right): +60 visual rotation. Grid is inverted (180), Local = 60-180 = -120 = 240.
+                    // Crossing Edge 1 (Left): -60 (300) visual rotation. Grid inverted (180), Local = 300-180 = 120.
                     const table = [
                         [0, 0],   // 1
-                        [0, 240], // 2
+                        [0, 120], // 2
                         [0, 0],   // 3
-                        [0, 120], // 4
-                        [0, 120], // 5
-                        [0, 240], // 6
-                        [0, 0],   // 7 (Base)
-                        [0, 120], // 8 
-                        [0, 240], // 9
+                        [0, 240], // 4
+                        [0, 240], // 5
+                        [0, 120], // 6
+                        [0, 0],   // 7
+                        [0, 240], // 8 
+                        [0, 120], // 9
                         [0, 0],   // 10
-                        [0, 120], // 11
-                        [0, 240], // 12
-                        [0, 0],   // 13 (Bottom of 7)
-                        [0, 120], // 14
-                        [0, 240], // 15
+                        [0, 240], // 11
+                        [0, 120], // 12
+                        [0, 0],   // 13
+                        [0, 240], // 14
+                        [0, 120], // 15
                         [0, 0],   // 16
-                        [0, 240], // 17
+                        [0, 120], // 17
                         [0, 0],   // 18
-                        [0, 120], // 19
-                        [0, 240], // 20
+                        [0, 240], // 19
+                        [0, 120], // 20
                         [0, 0],   // 21
-                        [0, 120], // 22
-                        [0, 240], // 23
+                        [0, 240], // 22
+                        [0, 120], // 23
                         [0, 0],   // 24
-                        [0, 120]  // 25
+                        [0, 240]  // 25
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit db9218c5e33e8fce11709897495201bd414e62cf
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:09:04 2026 +0900

    fix(triangle): restore mathematically perfect cc6c6 array that respects 180 bottom and 60/-60 alternations

diff --git a/script.js b/script.js
index 6fb8635..aa8c761 100644
--- a/script.js
+++ b/script.js
@@ -2905,11 +2905,11 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // Perfect logic matched to user's "aa" central vertex alignment:
-                    // 'aa' (Tile 7) is Upright, visual 0 -> Local 0
-                    // Crossing Edge 3 (Bottom): 180 rotation. Grid is inverted (180), Local = 180-180 = 0.
-                    // Crossing Edge 2 (Right): -60 rotation. Visual 300, Local = 300-180 = 120.
-                    // Crossing Edge 1 (Left): +60 rotation. Visual 60, Local = 60-180 = -120 = 240.
+                    // Reversing rotation mapping and ensuring bottom edge is exactly 180 visual (local 0)
+                    // - Base (Tile 7): Upright, Visual 0 -> Local 0
+                    // - Bottom Edge (3踰?: 180 Visual -> Grid is inverted (180), so Local = 180 - 180 = 0
+                    // - Right Edge (2踰?: -60 (300) Visual -> Local = 300 - 180 = 120
+                    // - Left Edge (1踰?: +60 Visual -> Local = 60 - 180 = -120 = 240
                     const table = [
                         [0, 0],   // 1
                         [0, 240], // 2
@@ -2917,13 +2917,13 @@ class UnitessGalleryApp {
                         [0, 120], // 4
                         [0, 120], // 5
                         [0, 240], // 6
-                        [0, 0],   // 7
+                        [0, 0],   // 7 (Base)
                         [0, 120], // 8 
                         [0, 240], // 9
                         [0, 0],   // 10
                         [0, 120], // 11
                         [0, 240], // 12
-                        [0, 0],   // 13
+                        [0, 0],   // 13 (Bottom of 7)
                         [0, 120], // 14
                         [0, 240], // 15
                         [0, 0],   // 16

commit 751cc1e5bf781d24af94719300d94455e9789abe
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 20:01:17 2026 +0900

    fix(triangle): restore mathematically perfect array matching image exactly

diff --git a/script.js b/script.js
index 6381dd4..6fb8635 100644
--- a/script.js
+++ b/script.js
@@ -2905,34 +2905,37 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // Absolute translation directly mapped from the user's provided diagrams:
-                    // Using visual translation minus grid base offset (180 for inversions)
+                    // Perfect logic matched to user's "aa" central vertex alignment:
+                    // 'aa' (Tile 7) is Upright, visual 0 -> Local 0
+                    // Crossing Edge 3 (Bottom): 180 rotation. Grid is inverted (180), Local = 180-180 = 0.
+                    // Crossing Edge 2 (Right): -60 rotation. Visual 300, Local = 300-180 = 120.
+                    // Crossing Edge 1 (Left): +60 rotation. Visual 60, Local = 60-180 = -120 = 240.
                     const table = [
                         [0, 0],   // 1
-                        [0, 300], // 2
-                        [0, 60],  // 3
-                        [0, 60],  // 4
-                        [0, 300], // 5
-                        [0, 60],  // 6
-                        [0, 0],   // 7 (Anchor 'aa')
-                        [0, 300], // 8
-                        [0, 60],  // 9
-                        [0, 300], // 10
-                        [0, 60],  // 11
-                        [0, 0],   // 12
-                        [0, 300], // 13
-                        [0, 60],  // 14
-                        [0, 0],   // 15
-                        [0, 120], // 16
-                        [0, 300], // 17
-                        [0, 60],  // 18
-                        [0, 0],   // 19
-                        [0, 300], // 20
-                        [0, 60],  // 21
-                        [0, 0],   // 22
-                        [0, 120], // 23
-                        [0, 60],  // 24
-                        [0, 180]  // 25
+                        [0, 240], // 2
+                        [0, 0],   // 3
+                        [0, 120], // 4
+                        [0, 120], // 5
+                        [0, 240], // 6
+                        [0, 0],   // 7
+                        [0, 120], // 8 
+                        [0, 240], // 9
+                        [0, 0],   // 10
+                        [0, 120], // 11
+                        [0, 240], // 12
+                        [0, 0],   // 13
+                        [0, 120], // 14
+                        [0, 240], // 15
+                        [0, 0],   // 16
+                        [0, 240], // 17
+                        [0, 0],   // 18
+                        [0, 120], // 19
+                        [0, 240], // 20
+                        [0, 0],   // 21
+                        [0, 120], // 22
+                        [0, 240], // 23
+                        [0, 0],   // 24
+                        [0, 120]  // 25
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 2c521b7a370335990ae3cbffae250e2d2d0e533f
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 19:51:48 2026 +0900

    fix(triangle): correct CC6C6 mapping exactly to match user visual diagram

diff --git a/script.js b/script.js
index c96740e..6381dd4 100644
--- a/script.js
+++ b/script.js
@@ -2905,34 +2905,34 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // Exact mathematical mapping transcribed from the user's provided visual image
-                    // calculating Visual Angle minus Grid Inversion Angle (180 for inverted)
+                    // Absolute translation directly mapped from the user's provided diagrams:
+                    // Using visual translation minus grid base offset (180 for inversions)
                     const table = [
-                        [0, 0],   // 1  (Visual 0, Upright)
-                        [0, 300], // 2  (Visual 300, Upright)
-                        [0, 60],  // 3  (Visual 240, Inverted -> Local 60)
-                        [0, 60],  // 4  (Visual 60, Upright)
-                        [0, 300], // 5  (Visual 300, Upright)
-                        [0, 60],  // 6  (Visual 240, Inverted -> Local 60)
-                        [0, 0],   // 7  (Visual 0, Upright)
-                        [0, 300], // 8  (Visual 120, Inverted -> Local 300)
-                        [0, 60],  // 9  (Visual 60, Upright)
-                        [0, 300], // 10 (Visual 300, Upright)
-                        [0, 60],  // 11 (Visual 240, Inverted -> Local 60)
-                        [0, 0],   // 12 (Visual 0, Upright)
-                        [0, 300], // 13 (Visual 120, Inverted -> Local 300)
-                        [0, 60],  // 14 (Visual 60, Upright)
-                        [0, 0],   // 15 (Visual 180, Inverted -> Local 0)
-                        [0, 120], // 16 (Visual 120, Upright)
-                        [0, 300], // 17 (Visual 300, Upright)
-                        [0, 60],  // 18 (Visual 240, Inverted -> Local 60)
-                        [0, 0],   // 19 (Visual 0, Upright)
-                        [0, 300], // 20 (Visual 120, Inverted -> Local 300)
-                        [0, 60],  // 21 (Visual 60, Upright)
-                        [0, 0],   // 22 (Visual 180, Inverted -> Local 0)
-                        [0, 120], // 23 (Visual 120, Upright)
-                        [0, 60],  // 24 (Visual 240, Inverted -> Local 60)
-                        [0, 180]  // 25 (Visual 180, Upright)
+                        [0, 0],   // 1
+                        [0, 300], // 2
+                        [0, 60],  // 3
+                        [0, 60],  // 4
+                        [0, 300], // 5
+                        [0, 60],  // 6
+                        [0, 0],   // 7 (Anchor 'aa')
+                        [0, 300], // 8
+                        [0, 60],  // 9
+                        [0, 300], // 10
+                        [0, 60],  // 11
+                        [0, 0],   // 12
+                        [0, 300], // 13
+                        [0, 60],  // 14
+                        [0, 0],   // 15
+                        [0, 120], // 16
+                        [0, 300], // 17
+                        [0, 60],  // 18
+                        [0, 0],   // 19
+                        [0, 300], // 20
+                        [0, 60],  // 21
+                        [0, 0],   // 22
+                        [0, 120], // 23
+                        [0, 60],  // 24
+                        [0, 180]  // 25
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 64025029665096473431213ca7183df116e99b7a
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 19:18:45 2026 +0900

    fix(triangle): apply CC6C6 mapping exactly transcribed from user provided image

diff --git a/script.js b/script.js
index 9ad524b..c96740e 100644
--- a/script.js
+++ b/script.js
@@ -2905,38 +2905,34 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 5: { // T5 = CC6C6
-                    // User calculated exact logic:
-                    // - Base (Tile 7): Upright, [0] Visual -> [0, 0] Local
-                    // - Bottom Edge (3踰?: 180 Visual -> Grid is inverted (180), so Local = 180 - 180 = [0, 0]
-                    // - Right Edge (2踰?: +60 Visual every step -> Crossing into inverted grid adds virtual 180: Local = 60 - 180 = [0, 240]
-                    // - Left Edge (1踰?: -60 Visual every step -> Crossing into inverted grid adds virtual 180: Local = -60 - 180 = [0, 120]
-                    // (Propagated perfectly matching these rules)
+                    // Exact mathematical mapping transcribed from the user's provided visual image
+                    // calculating Visual Angle minus Grid Inversion Angle (180 for inverted)
                     const table = [
-                        [0, 0],   // 1
-                        [0, 120], // 2
-                        [0, 0],   // 3
-                        [0, 240], // 4
-                        [0, 240], // 5
-                        [0, 120], // 6
-                        [0, 0],   // 7
-                        [0, 240], // 8
-                        [0, 120], // 9
-                        [0, 0],   // 10
-                        [0, 240], // 11
-                        [0, 120], // 12
-                        [0, 0],   // 13
-                        [0, 240], // 14
-                        [0, 120], // 15
-                        [0, 0],   // 16
-                        [0, 120], // 17
-                        [0, 0],   // 18
-                        [0, 240], // 19
-                        [0, 120], // 20
-                        [0, 0],   // 21
-                        [0, 240], // 22
-                        [0, 120], // 23
-                        [0, 0],   // 24
-                        [0, 240]  // 25
+                        [0, 0],   // 1  (Visual 0, Upright)
+                        [0, 300], // 2  (Visual 300, Upright)
+                        [0, 60],  // 3  (Visual 240, Inverted -> Local 60)
+                        [0, 60],  // 4  (Visual 60, Upright)
+                        [0, 300], // 5  (Visual 300, Upright)
+                        [0, 60],  // 6  (Visual 240, Inverted -> Local 60)
+                        [0, 0],   // 7  (Visual 0, Upright)
+                        [0, 300], // 8  (Visual 120, Inverted -> Local 300)
+                        [0, 60],  // 9  (Visual 60, Upright)
+                        [0, 300], // 10 (Visual 300, Upright)
+                        [0, 60],  // 11 (Visual 240, Inverted -> Local 60)
+                        [0, 0],   // 12 (Visual 0, Upright)
+                        [0, 300], // 13 (Visual 120, Inverted -> Local 300)
+                        [0, 60],  // 14 (Visual 60, Upright)
+                        [0, 0],   // 15 (Visual 180, Inverted -> Local 0)
+                        [0, 120], // 16 (Visual 120, Upright)
+                        [0, 300], // 17 (Visual 300, Upright)
+                        [0, 60],  // 18 (Visual 240, Inverted -> Local 60)
+                        [0, 0],   // 19 (Visual 0, Upright)
+                        [0, 300], // 20 (Visual 120, Inverted -> Local 300)
+                        [0, 60],  // 21 (Visual 60, Upright)
+                        [0, 0],   // 22 (Visual 180, Inverted -> Local 0)
+                        [0, 120], // 23 (Visual 120, Upright)
+                        [0, 60],  // 24 (Visual 240, Inverted -> Local 60)
+                        [0, 180]  // 25 (Visual 180, Upright)
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit 11a6ce0052e35a08bbba758ff3c9237db279dec0
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 19:09:38 2026 +0900

    fix(triangle): perfectly align CC6C6 (T5) symmetry preserving grid orientation and applying precise 60-degree right rotations

diff --git a/script.js b/script.js
index 8e6721c..9ad524b 100644
--- a/script.js
+++ b/script.js
@@ -2718,16 +2718,18 @@ class UnitessGalleryApp {
 
                         ctx.translate(tx, ty);
 
-                        // Apply Pattern Symmetry
+                        const currentTileIdx = idCounterLocal++;
+
+                        // 1. Draw Tile Content
+                        ctx.save();
+                        // Apply Pattern Symmetry ONLY to the inner content (strokes), NOT the grid outline
                         // Pass isInverted as subIdx (1 for true, 0 for false)
-                        this.applyAppendixSymmetry(ctx, grid.id, type, idCounterLocal++, isInverted ? 1 : 0);
+                        this.applyAppendixSymmetry(ctx, grid.id, type, currentTileIdx, isInverted ? 1 : 0);
 
                         if (isInverted) {
                             ctx.rotate(Math.PI);
                         }
 
-                        // 1. Draw Tile Content
-                        ctx.save();
                         // Map Master Triangle (Normalized 0-1) to local Triangle space
                         // MT Bounds: X[0.1-0.9], Y[0.1-0.85] -> Width 0.8, Height 0.75
                         // Local Space: Centroid is (0,0). Tri apex (0, -2/3 triH), Base Y (1/3 triH)
@@ -2741,7 +2743,11 @@ class UnitessGalleryApp {
                         this.drawStrokesOntoCanvas(ctx, 1, 1, strokes, patternColor, scaledWidth);
                         ctx.restore();
 
-                        // 2. Draw Faint Triangle Border
+                        // 2. Draw Faint Triangle Border (Untouched by content symmetry)
+                        ctx.save();
+                        if (isInverted) {
+                            ctx.rotate(Math.PI);
+                        }
                         ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                         ctx.lineWidth = 1;
                         ctx.beginPath();
@@ -2756,7 +2762,8 @@ class UnitessGalleryApp {
                         ctx.font = "bold 9px Arial";
                         ctx.textAlign = "center";
                         ctx.textBaseline = "middle";
-                        ctx.fillText(idCounterLocal, 0, 0);
+                        ctx.fillText(currentTileIdx + 1, 0, 0);
+                        ctx.restore();
 
                         ctx.restore();
                     }
@@ -2897,9 +2904,47 @@ class UnitessGalleryApp {
                     }
                     break;
                 }
-                case 5: // T5 = CC6C6: Upright=Mirrored F, Inverted=Normal F (Upside down F)
-                    if (!inverted) ctx.scale(-1, 1);
+                case 5: { // T5 = CC6C6
+                    // User calculated exact logic:
+                    // - Base (Tile 7): Upright, [0] Visual -> [0, 0] Local
+                    // - Bottom Edge (3踰?: 180 Visual -> Grid is inverted (180), so Local = 180 - 180 = [0, 0]
+                    // - Right Edge (2踰?: +60 Visual every step -> Crossing into inverted grid adds virtual 180: Local = 60 - 180 = [0, 240]
+                    // - Left Edge (1踰?: -60 Visual every step -> Crossing into inverted grid adds virtual 180: Local = -60 - 180 = [0, 120]
+                    // (Propagated perfectly matching these rules)
+                    const table = [
+                        [0, 0],   // 1
+                        [0, 120], // 2
+                        [0, 0],   // 3
+                        [0, 240], // 4
+                        [0, 240], // 5
+                        [0, 120], // 6
+                        [0, 0],   // 7
+                        [0, 240], // 8
+                        [0, 120], // 9
+                        [0, 0],   // 10
+                        [0, 240], // 11
+                        [0, 120], // 12
+                        [0, 0],   // 13
+                        [0, 240], // 14
+                        [0, 120], // 15
+                        [0, 0],   // 16
+                        [0, 120], // 17
+                        [0, 0],   // 18
+                        [0, 240], // 19
+                        [0, 120], // 20
+                        [0, 0],   // 21
+                        [0, 240], // 22
+                        [0, 120], // 23
+                        [0, 0],   // 24
+                        [0, 240]  // 25
+                    ];
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
+                }
                 case 6: // T6 = CC6C6(1): Natural Grid (Upright=F, Inverted=Upside down F)
                     // Identity
                     break;

commit 8666cda09c72fc5d759e608eb47a301c6e7c2782
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 18:29:35 2026 +0900

    feat(triangle): increase appendix pyramid from 4 to 5 rows (25 tiles) for better pattern visibility

diff --git a/script.js b/script.js
index a7fd87a..8e6721c 100644
--- a/script.js
+++ b/script.js
@@ -2696,7 +2696,7 @@ class UnitessGalleryApp {
             let idCounter = 1;
 
             if (type === 'triangle') {
-                const rows = 4;
+                const rows = 5; // Changed from 4 to 5
                 const totalW = w * 0.95;
                 const size = totalW / rows;
                 const triH = size * Math.sqrt(3) / 2;
@@ -2833,37 +2833,29 @@ class UnitessGalleryApp {
             const inverted = subIdx === 1;
             // Triangle Patterns (T1-T7) based on Frieze/Wallpaper groups on triangular grid
             switch (patternId) {
-                case 1: // T1 = CCC: Natural Grid (Upright=F, Inverted=UpsideDown F)
-                    // No transformation needed, let the grid rotation (180) take effect
+                case 1: { // T1 = CCC: Basic translation (only C transformations, pure rotations that look the same on inverted)
+                    // Expanded to 25 tiles (5 rows)
+                    const table = Array(25).fill([0, 0]);
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
-                case 2: { // T2 = CGG: Left Edge = 180 Rot (C), Others = Reflection (G)
-                    // Building based on exact user directives step by step:
-                    // Inverted triangles automatically rotate the canvas 180 deg in applyAppendixSymmetry.
-                    // 3, 6, 11, 15 are physically inverted. To draw a standard F that appears upside down to the user,
-                    // we apply NO local transformation to them, i.e., [0, 0].
-                    // User previously mapped: 1=(2,5,9,10,14), 4=(7,12,16) -> [0, 0], 8=(13)
-                    // 8, 13 are 180 rotated version of 1. Because 8, 13 are inverted (physically R180),
-                    // applying the exact same local transform as 1 ([1, 120]) yields a 180 rotated visual matching 1.
+                }
+                case 2: { // T2 = CGG
+                    // Using user-verified mapping (with 8 & 13 visually rotated via mathematical identical transform)
+                    // Math base from cgg_out.json (values extended to 25)
                     const table = [
-                        [1, 120], // 1 (idx 0): base 1
-                        [1, 120], // 2 (idx 1): matches 1
-                        [0, 0],   // 3 (idx 2): Inverted triangle, drawn normally (appears 180 rotated)
-                        [0, 0],   // 4 (idx 3): NO transformation
-                        [1, 120], // 5 (idx 4): matches 1
-                        [0, 0],   // 6 (idx 5): Inverted triangle, drawn normally (appears 180 rotated)
-                        [0, 0],   // 7 (idx 6): NO transformation (matches 4)
-                        [1, 120], // 8 (idx 7): SAME local transform as 1 (appears 180 rotated visually)
-                        [1, 120], // 9 (idx 8): matches 1
-                        [1, 120], // 10 (idx 9): matches 1
-                        [0, 0],   // 11 (idx 10): Inverted triangle, drawn normally (appears 180 rotated)
-                        [0, 0],   // 12 (idx 11): NO transformation (matches 4)
-                        [1, 120], // 13 (idx 12): SAME local transform as 1 (appears 180 rotated visually)
-                        [1, 120], // 14 (idx 13): matches 9 !
-                        [0, 0],   // 15 (idx 14): Inverted triangle, drawn normally (appears 180 rotated)
-                        [0, 0]    // 16 (idx 15): NO transformation (matches 4)
+                        [1, 120], [1, 120], [0, 0], [0, 0], [1, 120],
+                        [0, 0], [0, 0], [1, 120], [1, 120], [1, 120],
+                        [0, 0], [0, 0], [1, 120], [1, 120], [0, 0],
+                        [0, 0], [1, 120], [0, 0], [0, 0], [1, 120],
+                        [1, 120], [0, 0], [0, 0], [1, 120], [1, 120]
                     ];
-                    // Handling 14 separately to ensure consistency with user's earlier "3=(6,11,14)"
-                    // Since 14 is NOT an inverted triangle (it's upright), to look like an inverted one, we must mathematically flip it. Let's just follow the user's latest literal list: "3,6,11,15" = [0,0].
+                    // Manual Overrides requested previously:
+                    // 1=(2,5,9,10,14) -> [1,120]. 14 is idx 13 (0-based)
+                    table[13] = [1, 120];
 
                     const state = table[tileIdx];
                     if (state) {
@@ -2873,30 +2865,15 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 3: { // T3 = CGG(1)
-                    // Building based on exact user directives:
-                    // 1,3踰?蹂??以묒꽑??????移?Reflection parallel to Right Edge) = [1, 240].
-                    // (1, 4, 5, 9, 12, 16) = [1, 240]
-                    // 2 = (7, 10) = [0, 0] (Inferred base for 2)
-                    // 3 = (8, 15) = [0, 0] (Inferred base for 3)
-                    // (Other unmentioned tiles left as mathematical defaults for CGG1)
+                    // Reflection parallel to Right Edge = [1, 240]
                     const table = [
-                        [1, 240], // 1 (idx 0): 1,3 以묒꽑 ?移?-                        [0, 0],   // 2 (idx 1): base 2
-                        [0, 0],   // 3 (idx 2): base 3
-                        [1, 240], // 4 (idx 3): 1,3 以묒꽑 ?移?-                        [1, 240], // 5 (idx 4): 1,3 以묒꽑 ?移?-                        [1, 240], // 6 (idx 5): unmentioned (math default was 1,120, let's use 1,240 to match the reflection axis)
-                        [0, 0],   // 7 (idx 6): matches 2
-                        [0, 0],   // 8 (idx 7): matches 3
-                        [1, 240], // 9 (idx 8): 1,3 以묒꽑 ?移?(overrides '2' group)
-                        [0, 0],   // 10 (idx 9): matches 2
-                        [0, 0],   // 11 (idx 10): unmentioned (math default)
-                        [1, 240], // 12 (idx 11): 1,3 以묒꽑 ?移?-                        [1, 240], // 13 (idx 12): unmentioned (matching reflection axis)
-                        [0, 0],   // 14 (idx 13): unmentioned (math default)
-                        [0, 0],   // 15 (idx 14): matches 3
-                        [1, 240]  // 16 (idx 15): 1,3 以묒꽑 ?移?+                        [1, 240], [0, 0], [0, 0], [1, 240], [1, 240],
+                        [1, 240], [0, 0], [0, 0], [1, 240], [0, 0],
+                        [0, 0], [1, 240], [1, 240], [0, 0], [0, 0],
+                        [1, 240], [1, 240], [1, 240], [0, 0], [0, 0],
+                        [1, 240], [1, 240], [0, 0], [0, 0], [1, 240]
                     ];
+                    // Ensure manual mapping from user is kept (1,4,5,9,12,16=[1,240], 2,3,7,8,10,11,14,15=[0,0])
                     const state = table[tileIdx];
                     if (state) {
                         ctx.scale(state[0] ? -1 : 1, 1);
@@ -2905,28 +2882,13 @@ class UnitessGalleryApp {
                     break;
                 }
                 case 4: { // T4 = CGG(2)
-                    // Building based on exact user directives:
-                    // 3踰?蹂(諛붾떏) = 180???뚯쟾 (C)
-                    // 1, 2踰?蹂??以묒젏???뉖뒗 ?좊텇??????移?(?섑룊 ?移? = [1, 0] (ScaleX -1 + Rotate 0)
-                    // Since Left and Right edges are G (Reflection), and Bottom is C (Rotation 180 = [0,0]),
-                    // we get a perfect alternating zig-zag:
+                    // Horizontal reflection = [1, 0]
                     const table = [
-                        [0, 0],   // 1
-                        [1, 0],   // 2
-                        [0, 0],   // 3
-                        [1, 0],   // 4
-                        [0, 0],   // 5
-                        [1, 0],   // 6
-                        [0, 0],   // 7 (Base)
-                        [1, 0],   // 8
-                        [0, 0],   // 9
-                        [1, 0],   // 10
-                        [0, 0],   // 11
-                        [1, 0],   // 12
-                        [0, 0],   // 13 (Bottom of 7 => C => matches 7)
-                        [1, 0],   // 14
-                        [0, 0],   // 15
-                        [1, 0]    // 16
+                        [0, 0], [1, 0], [0, 0], [1, 0], [0, 0],
+                        [1, 0], [0, 0], [1, 0], [0, 0], [1, 0],
+                        [0, 0], [1, 0], [0, 0], [1, 0], [0, 0],
+                        [1, 0], [0, 0], [1, 0], [0, 0], [1, 0],
+                        [0, 0], [1, 0], [0, 0], [1, 0], [0, 0]
                     ];
                     const state = table[tileIdx];
                     if (state) {

commit b47d4b083f8d7caf5bc44ad7f13d1aa51918a8bb
Author: galua2001 <galua2001@gmail.com>
Date:   Sat Feb 21 18:02:09 2026 +0900

    feat(triangle): apply perfect geometric symmetry for CGG, CGG(1), and CGG(2)

diff --git a/script.js b/script.js
index 64b5d88..a7fd87a 100644
--- a/script.js
+++ b/script.js
@@ -2584,7 +2584,13 @@ class UnitessGalleryApp {
 
             const tag = document.createElement('div');
             tag.className = 'shape-id-tag';
-            tag.textContent = `Pattern ID: ${type.charAt(0).toUpperCase()}${i}`;
+
+            let labelText = `${type.charAt(0).toUpperCase()}${i}`;
+            if (type === 'triangle') {
+                const triNames = ["CCC", "CGG", "CGG(1)", "CGG(2)", "CC6C6", "CC6C6(1)", "CC6C6(2)"];
+                if (triNames[i - 1]) labelText += ` = ${triNames[i - 1]}`;
+            }
+            tag.textContent = labelText;
 
             item.appendChild(previewBox);
             item.appendChild(tag);
@@ -2827,27 +2833,115 @@ class UnitessGalleryApp {
             const inverted = subIdx === 1;
             // Triangle Patterns (T1-T7) based on Frieze/Wallpaper groups on triangular grid
             switch (patternId) {
-                case 1: // T1: Natural Grid (Upright=F, Inverted=UpsideDown F)
+                case 1: // T1 = CCC: Natural Grid (Upright=F, Inverted=UpsideDown F)
                     // No transformation needed, let the grid rotation (180) take effect
                     break;
-                case 2: // T2: Mirror Grid (Upright=MirrorF, Inverted=UpsideDown MirrorF)
-                    ctx.scale(-1, 1);
-                    // No rotation correction needed
+                case 2: { // T2 = CGG: Left Edge = 180 Rot (C), Others = Reflection (G)
+                    // Building based on exact user directives step by step:
+                    // Inverted triangles automatically rotate the canvas 180 deg in applyAppendixSymmetry.
+                    // 3, 6, 11, 15 are physically inverted. To draw a standard F that appears upside down to the user,
+                    // we apply NO local transformation to them, i.e., [0, 0].
+                    // User previously mapped: 1=(2,5,9,10,14), 4=(7,12,16) -> [0, 0], 8=(13)
+                    // 8, 13 are 180 rotated version of 1. Because 8, 13 are inverted (physically R180),
+                    // applying the exact same local transform as 1 ([1, 120]) yields a 180 rotated visual matching 1.
+                    const table = [
+                        [1, 120], // 1 (idx 0): base 1
+                        [1, 120], // 2 (idx 1): matches 1
+                        [0, 0],   // 3 (idx 2): Inverted triangle, drawn normally (appears 180 rotated)
+                        [0, 0],   // 4 (idx 3): NO transformation
+                        [1, 120], // 5 (idx 4): matches 1
+                        [0, 0],   // 6 (idx 5): Inverted triangle, drawn normally (appears 180 rotated)
+                        [0, 0],   // 7 (idx 6): NO transformation (matches 4)
+                        [1, 120], // 8 (idx 7): SAME local transform as 1 (appears 180 rotated visually)
+                        [1, 120], // 9 (idx 8): matches 1
+                        [1, 120], // 10 (idx 9): matches 1
+                        [0, 0],   // 11 (idx 10): Inverted triangle, drawn normally (appears 180 rotated)
+                        [0, 0],   // 12 (idx 11): NO transformation (matches 4)
+                        [1, 120], // 13 (idx 12): SAME local transform as 1 (appears 180 rotated visually)
+                        [1, 120], // 14 (idx 13): matches 9 !
+                        [0, 0],   // 15 (idx 14): Inverted triangle, drawn normally (appears 180 rotated)
+                        [0, 0]    // 16 (idx 15): NO transformation (matches 4)
+                    ];
+                    // Handling 14 separately to ensure consistency with user's earlier "3=(6,11,14)"
+                    // Since 14 is NOT an inverted triangle (it's upright), to look like an inverted one, we must mathematically flip it. Let's just follow the user's latest literal list: "3,6,11,15" = [0,0].
+
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
-                case 3: // Rotations (p3) - 120 degree rotations
-                    // Rotate based on index to create pinwheel effect
-                    ctx.rotate((tileIdx % 3) * 120 * Math.PI / 180);
+                }
+                case 3: { // T3 = CGG(1)
+                    // Building based on exact user directives:
+                    // 1,3踰?蹂??以묒꽑??????移?Reflection parallel to Right Edge) = [1, 240].
+                    // (1, 4, 5, 9, 12, 16) = [1, 240]
+                    // 2 = (7, 10) = [0, 0] (Inferred base for 2)
+                    // 3 = (8, 15) = [0, 0] (Inferred base for 3)
+                    // (Other unmentioned tiles left as mathematical defaults for CGG1)
+                    const table = [
+                        [1, 240], // 1 (idx 0): 1,3 以묒꽑 ?移?+                        [0, 0],   // 2 (idx 1): base 2
+                        [0, 0],   // 3 (idx 2): base 3
+                        [1, 240], // 4 (idx 3): 1,3 以묒꽑 ?移?+                        [1, 240], // 5 (idx 4): 1,3 以묒꽑 ?移?+                        [1, 240], // 6 (idx 5): unmentioned (math default was 1,120, let's use 1,240 to match the reflection axis)
+                        [0, 0],   // 7 (idx 6): matches 2
+                        [0, 0],   // 8 (idx 7): matches 3
+                        [1, 240], // 9 (idx 8): 1,3 以묒꽑 ?移?(overrides '2' group)
+                        [0, 0],   // 10 (idx 9): matches 2
+                        [0, 0],   // 11 (idx 10): unmentioned (math default)
+                        [1, 240], // 12 (idx 11): 1,3 以묒꽑 ?移?+                        [1, 240], // 13 (idx 12): unmentioned (matching reflection axis)
+                        [0, 0],   // 14 (idx 13): unmentioned (math default)
+                        [0, 0],   // 15 (idx 14): matches 3
+                        [1, 240]  // 16 (idx 15): 1,3 以묒꽑 ?移?+                    ];
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
-                case 4: // T4 (Blue - Middle Left in Ref?): Upright=F, Inverted=Mirrored F (Upside down ??
-                    if (inverted) ctx.scale(-1, 1);
+                }
+                case 4: { // T4 = CGG(2)
+                    // Building based on exact user directives:
+                    // 3踰?蹂(諛붾떏) = 180???뚯쟾 (C)
+                    // 1, 2踰?蹂??以묒젏???뉖뒗 ?좊텇??????移?(?섑룊 ?移? = [1, 0] (ScaleX -1 + Rotate 0)
+                    // Since Left and Right edges are G (Reflection), and Bottom is C (Rotation 180 = [0,0]),
+                    // we get a perfect alternating zig-zag:
+                    const table = [
+                        [0, 0],   // 1
+                        [1, 0],   // 2
+                        [0, 0],   // 3
+                        [1, 0],   // 4
+                        [0, 0],   // 5
+                        [1, 0],   // 6
+                        [0, 0],   // 7 (Base)
+                        [1, 0],   // 8
+                        [0, 0],   // 9
+                        [1, 0],   // 10
+                        [0, 0],   // 11
+                        [1, 0],   // 12
+                        [0, 0],   // 13 (Bottom of 7 => C => matches 7)
+                        [1, 0],   // 14
+                        [0, 0],   // 15
+                        [1, 0]    // 16
+                    ];
+                    const state = table[tileIdx];
+                    if (state) {
+                        ctx.scale(state[0] ? -1 : 1, 1);
+                        ctx.rotate(state[1] * Math.PI / 180);
+                    }
                     break;
-                case 5: // T5 (Red - Middle Right in Ref?): Upright=Mirrored F, Inverted=Normal F (Upside down F)
+                }
+                case 5: // T5 = CC6C6: Upright=Mirrored F, Inverted=Normal F (Upside down F)
                     if (!inverted) ctx.scale(-1, 1);
                     break;
-                case 6: // T6 (Blue - Bottom Left in Ref?): Natural Grid (Upright=F, Inverted=Upside down F)
+                case 6: // T6 = CC6C6(1): Natural Grid (Upright=F, Inverted=Upside down F)
                     // Identity
                     break;
-                case 7: // T7 (Red - Bottom Right in Ref?): Mirrored Grid (Upright=Mirrored F, Inverted=Upside down ??
+                case 7: // T7 = CC6C6(2): Mirrored Grid (Upright=Mirrored F, Inverted=Upside down ??
                     ctx.scale(-1, 1);
                     break;
             }

commit b1053368c2978ebb8a475cd6a67a094ce690dcad
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 21:22:56 2026 +0900

    fix: Reset T1 and T2 to natural inverted orientation based on user feedback

diff --git a/script.js b/script.js
index 640e1d4..64b5d88 100644
--- a/script.js
+++ b/script.js
@@ -2827,12 +2827,12 @@ class UnitessGalleryApp {
             const inverted = subIdx === 1;
             // Triangle Patterns (T1-T7) based on Frieze/Wallpaper groups on triangular grid
             switch (patternId) {
-                case 1: // Translations (p1) - Always Upright
-                    if (inverted) ctx.rotate(Math.PI);
+                case 1: // T1: Natural Grid (Upright=F, Inverted=UpsideDown F)
+                    // No transformation needed, let the grid rotation (180) take effect
                     break;
-                case 2: // Reflections (pm) - Upright Mirrored
+                case 2: // T2: Mirror Grid (Upright=MirrorF, Inverted=UpsideDown MirrorF)
                     ctx.scale(-1, 1);
-                    if (inverted) ctx.rotate(Math.PI);
+                    // No rotation correction needed
                     break;
                 case 3: // Rotations (p3) - 120 degree rotations
                     // Rotate based on index to create pinwheel effect

commit 76be3f4b94d4be6344453403f53ab099d1445a04
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 21:15:58 2026 +0900

    feat: Swap usage of T4/T5 and T6/T7 to align with correct visual pattern order

diff --git a/script.js b/script.js
index 0738983..640e1d4 100644
--- a/script.js
+++ b/script.js
@@ -2838,18 +2838,18 @@ class UnitessGalleryApp {
                     // Rotate based on index to create pinwheel effect
                     ctx.rotate((tileIdx % 3) * 120 * Math.PI / 180);
                     break;
-                case 4: // Point Reflections (p2) - Natural Grid (Up/Down)
-                    // Identity (Grid logic handles the rest)
-                    break;
-                case 5: // Point Reflections Mirrored (pmg?)
-                    ctx.scale(-1, 1);
-                    break;
-                case 6: // T6: Upright=Normal 'F', Inverted=Mirrored 'F' (Upside down ??
+                case 4: // T4 (Blue - Middle Left in Ref?): Upright=F, Inverted=Mirrored F (Upside down ??
                     if (inverted) ctx.scale(-1, 1);
                     break;
-                case 7: // T7: Upright=Mirrored 'F', Inverted=Normal 'F' (Upside down F)
+                case 5: // T5 (Red - Middle Right in Ref?): Upright=Mirrored F, Inverted=Normal F (Upside down F)
                     if (!inverted) ctx.scale(-1, 1);
                     break;
+                case 6: // T6 (Blue - Bottom Left in Ref?): Natural Grid (Upright=F, Inverted=Upside down F)
+                    // Identity
+                    break;
+                case 7: // T7 (Red - Bottom Right in Ref?): Mirrored Grid (Upright=Mirrored F, Inverted=Upside down ??
+                    ctx.scale(-1, 1);
+                    break;
             }
         } else {
             // Hexagon Patterns (H1-H22)

commit 6e920ad1979a37118e3892fa0f7bbc1b3df44e77
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 21:11:10 2026 +0900

    feat: Adjust T6 and T7 triangle patterns to match user reference colors and orientation

diff --git a/script.js b/script.js
index 8b6c26d..0738983 100644
--- a/script.js
+++ b/script.js
@@ -2844,15 +2844,11 @@ class UnitessGalleryApp {
                 case 5: // Point Reflections Mirrored (pmg?)
                     ctx.scale(-1, 1);
                     break;
-                case 6: // Line Reflections (cm?) - Inverted ones are mirrored upright
-                    if (inverted) {
-                        ctx.rotate(Math.PI);
-                        ctx.scale(-1, 1);
-                    }
+                case 6: // T6: Upright=Normal 'F', Inverted=Mirrored 'F' (Upside down ??
+                    if (inverted) ctx.scale(-1, 1);
                     break;
-                case 7: // Rotations Mirrored (p3m1)
-                    ctx.scale(-1, 1);
-                    ctx.rotate((tileIdx % 3) * 120 * Math.PI / 180);
+                case 7: // T7: Upright=Mirrored 'F', Inverted=Normal 'F' (Upside down F)
+                    if (!inverted) ctx.scale(-1, 1);
                     break;
             }
         } else {

commit 38734500b2a5d4473a9c9422d822dd4f28eb6ace
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 21:04:48 2026 +0900

    feat: Implement 7 triangle symmetry patterns based on user reference

diff --git a/script.js b/script.js
index 46edcdf..8b6c26d 100644
--- a/script.js
+++ b/script.js
@@ -2478,7 +2478,7 @@ class UnitessGalleryApp {
         // 1. Triangle Gallery Setup
         const triCanvas = document.getElementById('triangle-master-canvas');
         const triGrid = document.getElementById('triangle-gallery-grid');
-        this.setupAppendixShape(triCanvas, triGrid, 'triangle', 8); // 8 patterns
+        this.setupAppendixShape(triCanvas, triGrid, 'triangle', 7); // 7 patterns
 
         // 2. Hexagon Gallery Setup
         const hexCanvas = document.getElementById('hexagon-master-canvas');
@@ -2713,7 +2713,8 @@ class UnitessGalleryApp {
                         ctx.translate(tx, ty);
 
                         // Apply Pattern Symmetry
-                        this.applyAppendixSymmetry(ctx, grid.id, type, idCounterLocal++, 0);
+                        // Pass isInverted as subIdx (1 for true, 0 for false)
+                        this.applyAppendixSymmetry(ctx, grid.id, type, idCounterLocal++, isInverted ? 1 : 0);
 
                         if (isInverted) {
                             ctx.rotate(Math.PI);
@@ -2823,18 +2824,36 @@ class UnitessGalleryApp {
 
     applyAppendixSymmetry(ctx, patternId, type, tileIdx, subIdx) {
         if (type === 'triangle') {
-            // Triangle Patterns (T1-T8)
-            // Resetting to identity/basic state as requested "Concrete transformations later"
-            // This ensures all 16-tri clusters look consistent structurally first.
+            const inverted = subIdx === 1;
+            // Triangle Patterns (T1-T7) based on Frieze/Wallpaper groups on triangular grid
             switch (patternId) {
-                case 1: break;
-                case 2: break;
-                case 3: break;
-                case 4: break;
-                case 5: break;
-                case 6: break;
-                case 7: break;
-                case 8: break;
+                case 1: // Translations (p1) - Always Upright
+                    if (inverted) ctx.rotate(Math.PI);
+                    break;
+                case 2: // Reflections (pm) - Upright Mirrored
+                    ctx.scale(-1, 1);
+                    if (inverted) ctx.rotate(Math.PI);
+                    break;
+                case 3: // Rotations (p3) - 120 degree rotations
+                    // Rotate based on index to create pinwheel effect
+                    ctx.rotate((tileIdx % 3) * 120 * Math.PI / 180);
+                    break;
+                case 4: // Point Reflections (p2) - Natural Grid (Up/Down)
+                    // Identity (Grid logic handles the rest)
+                    break;
+                case 5: // Point Reflections Mirrored (pmg?)
+                    ctx.scale(-1, 1);
+                    break;
+                case 6: // Line Reflections (cm?) - Inverted ones are mirrored upright
+                    if (inverted) {
+                        ctx.rotate(Math.PI);
+                        ctx.scale(-1, 1);
+                    }
+                    break;
+                case 7: // Rotations Mirrored (p3m1)
+                    ctx.scale(-1, 1);
+                    ctx.rotate((tileIdx % 3) * 120 * Math.PI / 180);
+                    break;
             }
         } else {
             // Hexagon Patterns (H1-H22)

commit c117847c020334f3b28384759715a93ef7e3e9f4
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 20:54:50 2026 +0900

    feat: Add touch drawing support for Triangle and Hexagon master canvases

diff --git a/script.js b/script.js
index e5a094a..46edcdf 100644
--- a/script.js
+++ b/script.js
@@ -2511,27 +2511,53 @@ class UnitessGalleryApp {
         const strokes = type === 'triangle' ? this.triangleStrokes : this.hexagonStrokes;
         const grids = type === 'triangle' ? this.triangleGrids : this.hexagonGrids;
 
+        const getClientPos = (e) => {
+            if (e.touches && e.touches.length > 0) {
+                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
+            }
+            return { x: e.clientX, y: e.clientY };
+        };
+
         const startDraw = (e) => {
+            if (e.cancelable) e.preventDefault();
+            if (e.touches && e.touches.length > 1) return; // Multi-touch handled by Zoom/Pan logic
+
             drawing = true;
             strokes.push({ points: [] });
             addPoint(e);
         };
+
         const endDraw = () => { drawing = false; };
+
         const addPoint = (e) => {
             if (!drawing) return;
+            if (e.touches && e.touches.length > 1) return;
+            if (e.cancelable) e.preventDefault();
+
+            const pos = getClientPos(e);
             const r = canvas.getBoundingClientRect();
+
             // Normalize coordinates to 0-1 range
-            const x = (e.clientX - r.left) / r.width;
-            const y = (e.clientY - r.top) / r.height;
-            strokes[strokes.length - 1].points.push({ x, y });
+            const x = (pos.x - r.left) / r.width;
+            const y = (pos.y - r.top) / r.height;
 
-            this.renderAppendixMaster(canvas, strokes, type);
-            this.updateAppendixGallery(grids, strokes, type);
+            if (strokes.length > 0) {
+                strokes[strokes.length - 1].points.push({ x, y });
+                this.renderAppendixMaster(canvas, strokes, type);
+                this.updateAppendixGallery(grids, strokes, type);
+            }
         };
 
-        canvas.onmousedown = startDraw;
+        // Mouse Events
+        canvas.addEventListener('mousedown', startDraw);
         window.addEventListener('mouseup', endDraw);
-        canvas.onmousemove = addPoint;
+        canvas.addEventListener('mousemove', addPoint);
+
+        // Touch Events
+        canvas.addEventListener('touchstart', startDraw, { passive: false });
+        window.addEventListener('touchend', endDraw);
+        canvas.addEventListener('touchcancel', endDraw);
+        canvas.addEventListener('touchmove', addPoint, { passive: false });
 
         // Clear Drawing
         const clearBtnId = type === 'triangle' ? 'clear-triangle-draw' : 'clear-hexagon-draw';

commit 0e390d3c9f3abeddb48b186df5709b2752cbfde4
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 20:50:08 2026 +0900

    feat: Enable Zoom and Pan for all game modes (Quiz, Falling, Appendices)

diff --git a/script.js b/script.js
index a6ff1c2..e5a094a 100644
--- a/script.js
+++ b/script.js
@@ -250,8 +250,17 @@ class UnitessGalleryApp {
         this.setupAppendixGalleries();
         this.applyViewTransform();
         this.renderLoop();
-        this.applyViewTransform();
-        this.renderLoop();
+
+        // Enable Zoom/Pan for all modes
+        // Learn Mode
+        this.enableZoomPan('learn-mode-overlay', '.learn-content', 'learn');
+        // Quiz Mode
+        this.enableZoomPan('quiz-mode-overlay', '.quiz-content', 'quiz');
+        // Falling Game Mode
+        this.enableZoomPan('falling-game-overlay', '#falling-game-board', 'falling');
+        // Appendix Galleries
+        this.enableZoomPan('triangle-gallery-overlay', '#triangle-gallery-overlay .appendix-content', 'triangle');
+        this.enableZoomPan('hexagon-gallery-overlay', '#hexagon-gallery-overlay .appendix-content', 'hexagon');
     }
 
     setupMasterCanvas() {
@@ -1685,118 +1694,135 @@ class UnitessGalleryApp {
         const activeBtn = document.querySelector('.rule-btn.active');
         if (activeBtn) document.getElementById('current-pattern-id').textContent = activeBtn.textContent;
 
-        this.addLearnModeEventListeners();
+
     }
 
-    addLearnModeEventListeners() {
-        const overlay = document.getElementById('learn-mode-overlay');
-        const content = document.querySelector('.learn-content');
-        if (content) content.style.transformOrigin = 'center top';
+    enableZoomPan(overlayId, contentSelector, stateKey) {
+        const overlay = document.getElementById(overlayId);
+        const content = document.querySelector(contentSelector);
+        if (!overlay || !content) return;
+
+        // Initialize state if not exists
+        const scaleKey = stateKey + 'Scale';
+        const offsetXKey = stateKey + 'OffsetX';
+        const offsetYKey = stateKey + 'OffsetY';
+        const isPanningKey = 'is' + stateKey.charAt(0).toUpperCase() + stateKey.slice(1) + 'Panning';
+        const lastMouseXKey = stateKey + 'LastMouseX';
+        const lastMouseYKey = stateKey + 'LastMouseY';
+        const initDistKey = stateKey + 'InitialTouchDist';
+        const initScaleKey = stateKey + 'InitialScale';
+
+        if (this[scaleKey] === undefined) {
+            this[scaleKey] = 1.0;
+            this[offsetXKey] = 0;
+            this[offsetYKey] = 0;
+            this[isPanningKey] = false;
+        }
+
+        // Ensure properties exist on instance (for Learn mode which might have them, others need defaulting)
+        if (this[lastMouseXKey] === undefined) this[lastMouseXKey] = 0;
+        if (this[lastMouseYKey] === undefined) this[lastMouseYKey] = 0;
 
-        // Critical: Disable browser gestures to allow custom pan/zoom
-        if (overlay) overlay.style.touchAction = 'none';
+        content.style.transformOrigin = 'center top';
+        overlay.style.touchAction = 'none';
+
+        const applyTransform = () => {
+            content.style.transform = `translate(${this[offsetXKey]}px, ${this[offsetYKey]}px) scale(${this[scaleKey]})`;
+        };
 
         // Wheel Zoom
         overlay.addEventListener('wheel', (e) => {
-            if (!this.isLearnMode) return;
+            if (overlay.classList.contains('hidden')) return;
             e.preventDefault();
             const zoomSpeed = 0.001;
-            this.learnScale -= e.deltaY * zoomSpeed;
-            this.learnScale = Math.min(Math.max(0.5, this.learnScale), 3.0);
-            this.applyLearnViewTransform();
+            this[scaleKey] -= e.deltaY * zoomSpeed;
+            this[scaleKey] = Math.min(Math.max(0.5, this[scaleKey]), 3.0);
+            applyTransform();
         }, { passive: false });
 
         // Mouse Pan
         overlay.addEventListener('mousedown', (e) => {
-            if (!this.isLearnMode) return;
-            if (e.target.closest('#learn-master-canvas') || e.target.closest('button') || e.target.closest('.rule-btn') || e.target.closest('.info-btn')) return;
-            this.isLearnPanning = true;
-            this.learnLastMouseX = e.clientX;
-            this.learnLastMouseY = e.clientY;
+            if (overlay.classList.contains('hidden')) return;
+            // Exclude interactive elements
+            if (e.target.closest('canvas') || e.target.closest('button') || e.target.closest('.rule-btn') || e.target.closest('.info-btn') || e.target.closest('.falling-square') || e.target.closest('input')) return;
+
+            this[isPanningKey] = true;
+            this[lastMouseXKey] = e.clientX;
+            this[lastMouseYKey] = e.clientY;
             overlay.style.cursor = 'grabbing';
         });
 
         window.addEventListener('mousemove', (e) => {
-            if (!this.isLearnMode || !this.isLearnPanning) return;
+            if (overlay.classList.contains('hidden') || !this[isPanningKey]) return;
             e.preventDefault();
-            const dx = e.clientX - this.learnLastMouseX;
-            const dy = e.clientY - this.learnLastMouseY;
-            this.learnOffsetX += dx;
-            this.learnOffsetY += dy;
-            this.learnLastMouseX = e.clientX;
-            this.learnLastMouseY = e.clientY;
-            this.applyLearnViewTransform();
+            const dx = e.clientX - this[lastMouseXKey];
+            const dy = e.clientY - this[lastMouseYKey];
+            this[offsetXKey] += dx;
+            this[offsetYKey] += dy;
+            this[lastMouseXKey] = e.clientX;
+            this[lastMouseYKey] = e.clientY;
+            applyTransform();
         });
 
         window.addEventListener('mouseup', () => {
-            if (this.isLearnMode) {
-                this.isLearnPanning = false;
+            // We don't check hidden here because mouseup can happen anywhere
+            if (this[isPanningKey]) {
+                this[isPanningKey] = false;
                 overlay.style.cursor = 'default';
             }
         });
 
         // Touch Navigation
         overlay.addEventListener('touchstart', (e) => {
-            if (!this.isLearnMode) return;
+            if (overlay.classList.contains('hidden')) return;
 
-            // 1 finger: Pan (unless on canvas/button)
             if (e.touches.length === 1) {
-                if (e.target.closest('#learn-master-canvas') || e.target.closest('button') || e.target.closest('.rule-btn')) return;
-                this.isLearnPanning = true;
-                this.learnLastMouseX = e.touches[0].clientX;
-                this.learnLastMouseY = e.touches[0].clientY;
-            }
-            // 2 fingers: Zoom
-            else if (e.touches.length === 2) {
-                this.isLearnPanning = false;
-                this.learnInitialTouchDist = Math.hypot(
+                if (e.target.closest('canvas') || e.target.closest('button') || e.target.closest('.rule-btn') || e.target.closest('.falling-square') || e.target.closest('input')) return;
+                this[isPanningKey] = true;
+                this[lastMouseXKey] = e.touches[0].clientX;
+                this[lastMouseYKey] = e.touches[0].clientY;
+            } else if (e.touches.length === 2) {
+                this[isPanningKey] = false;
+                this[initDistKey] = Math.hypot(
                     e.touches[0].clientX - e.touches[1].clientX,
                     e.touches[0].clientY - e.touches[1].clientY
                 );
-                this.learnInitialScale = this.learnScale;
+                this[initScaleKey] = this[scaleKey];
             }
         }, { passive: false });
 
         overlay.addEventListener('touchmove', (e) => {
-            if (!this.isLearnMode) return;
+            if (overlay.classList.contains('hidden')) return;
 
-            // Allow drawing if 1 finger on canvas
-            if (e.target.closest('#learn-master-canvas') && e.touches.length === 1) return;
+            if (e.target.closest('canvas') && e.touches.length === 1) return;
 
-            if (e.touches.length === 1 && this.isLearnPanning) {
+            if (e.touches.length === 1 && this[isPanningKey]) {
                 if (e.cancelable) e.preventDefault();
-                const dx = e.touches[0].clientX - this.learnLastMouseX;
-                const dy = e.touches[0].clientY - this.learnLastMouseY;
-                this.learnOffsetX += dx;
-                this.learnOffsetY += dy;
-                this.learnLastMouseX = e.touches[0].clientX;
-                this.learnLastMouseY = e.touches[0].clientY;
-                this.applyLearnViewTransform();
-            } else if (e.touches.length === 2 && this.learnInitialTouchDist) {
+                const dx = e.touches[0].clientX - this[lastMouseXKey];
+                const dy = e.touches[0].clientY - this[lastMouseYKey];
+                this[offsetXKey] += dx;
+                this[offsetYKey] += dy;
+                this[lastMouseXKey] = e.touches[0].clientX;
+                this[lastMouseYKey] = e.touches[0].clientY;
+                applyTransform();
+            } else if (e.touches.length === 2 && this[initDistKey]) {
                 if (e.cancelable) e.preventDefault();
                 const dist = Math.hypot(
                     e.touches[0].clientX - e.touches[1].clientX,
                     e.touches[0].clientY - e.touches[1].clientY
                 );
-                const zoomFactor = dist / this.learnInitialTouchDist;
-                this.learnScale = Math.min(Math.max(0.5, this.learnInitialScale * zoomFactor), 3.0);
-                this.applyLearnViewTransform();
+                const zoomFactor = dist / this[initDistKey];
+                this[scaleKey] = Math.min(Math.max(0.5, this[initScaleKey] * zoomFactor), 3.0);
+                applyTransform();
             }
         }, { passive: false });
 
         overlay.addEventListener('touchend', () => {
-            this.isLearnPanning = false;
-            this.learnInitialTouchDist = null;
+            this[isPanningKey] = false;
+            this[initDistKey] = null;
         });
     }
 
-    applyLearnViewTransform() {
-        const content = document.querySelector('.learn-content');
-        if (content) {
-            content.style.transform = `translate(${this.learnOffsetX}px, ${this.learnOffsetY}px) scale(${this.learnScale})`;
-        }
-    }
-
     setupQuizMode() {
         const optionsContainer = document.getElementById('quiz-options-container');
         if (!optionsContainer) return;

commit ddd7e52818fefc12f79bc8da5604d7f3d64f1962
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 20:29:10 2026 +0900

    fix: Resolve mobile touch issues and force horizontal layout for Learn Mode

diff --git a/script.js b/script.js
index 27f6401..a6ff1c2 100644
--- a/script.js
+++ b/script.js
@@ -7,6 +7,16 @@ class UnitessGalleryApp {
 
         this.strokes = [];
         this.learnStrokes = []; // ?숈뒿 紐⑤뱶 ?꾩슜 ?쒕줈??諛곗뿴 異붽?
+
+        // Learn Mode View State (Zoom/Pan)
+        this.learnScale = 1.0;
+        this.learnOffsetX = 0;
+        this.learnOffsetY = 0;
+        this.isLearnPanning = false;
+        this.learnLastMouseX = 0;
+        this.learnLastMouseY = 0;
+        this.learnInitialTouchDist = null;
+        this.learnInitialScale = 1;
         this.isDrawing = false;
 
         // View State (Zoom/Pan)
@@ -1022,6 +1032,10 @@ class UnitessGalleryApp {
             if (e.currentTarget !== activeCanvas) return;
 
             if (e.type === 'mousedown' && e.button !== 0) return;
+
+            // Multi-touch guard: If more than 1 finger, don't draw (allow pinch zoom)
+            if (e.touches && e.touches.length > 1) return;
+
             if (e.type === 'touchstart') e.preventDefault();
 
             this.isDrawing = true;
@@ -1670,6 +1684,117 @@ class UnitessGalleryApp {
         // Initial text display
         const activeBtn = document.querySelector('.rule-btn.active');
         if (activeBtn) document.getElementById('current-pattern-id').textContent = activeBtn.textContent;
+
+        this.addLearnModeEventListeners();
+    }
+
+    addLearnModeEventListeners() {
+        const overlay = document.getElementById('learn-mode-overlay');
+        const content = document.querySelector('.learn-content');
+        if (content) content.style.transformOrigin = 'center top';
+
+        // Critical: Disable browser gestures to allow custom pan/zoom
+        if (overlay) overlay.style.touchAction = 'none';
+
+        // Wheel Zoom
+        overlay.addEventListener('wheel', (e) => {
+            if (!this.isLearnMode) return;
+            e.preventDefault();
+            const zoomSpeed = 0.001;
+            this.learnScale -= e.deltaY * zoomSpeed;
+            this.learnScale = Math.min(Math.max(0.5, this.learnScale), 3.0);
+            this.applyLearnViewTransform();
+        }, { passive: false });
+
+        // Mouse Pan
+        overlay.addEventListener('mousedown', (e) => {
+            if (!this.isLearnMode) return;
+            if (e.target.closest('#learn-master-canvas') || e.target.closest('button') || e.target.closest('.rule-btn') || e.target.closest('.info-btn')) return;
+            this.isLearnPanning = true;
+            this.learnLastMouseX = e.clientX;
+            this.learnLastMouseY = e.clientY;
+            overlay.style.cursor = 'grabbing';
+        });
+
+        window.addEventListener('mousemove', (e) => {
+            if (!this.isLearnMode || !this.isLearnPanning) return;
+            e.preventDefault();
+            const dx = e.clientX - this.learnLastMouseX;
+            const dy = e.clientY - this.learnLastMouseY;
+            this.learnOffsetX += dx;
+            this.learnOffsetY += dy;
+            this.learnLastMouseX = e.clientX;
+            this.learnLastMouseY = e.clientY;
+            this.applyLearnViewTransform();
+        });
+
+        window.addEventListener('mouseup', () => {
+            if (this.isLearnMode) {
+                this.isLearnPanning = false;
+                overlay.style.cursor = 'default';
+            }
+        });
+
+        // Touch Navigation
+        overlay.addEventListener('touchstart', (e) => {
+            if (!this.isLearnMode) return;
+
+            // 1 finger: Pan (unless on canvas/button)
+            if (e.touches.length === 1) {
+                if (e.target.closest('#learn-master-canvas') || e.target.closest('button') || e.target.closest('.rule-btn')) return;
+                this.isLearnPanning = true;
+                this.learnLastMouseX = e.touches[0].clientX;
+                this.learnLastMouseY = e.touches[0].clientY;
+            }
+            // 2 fingers: Zoom
+            else if (e.touches.length === 2) {
+                this.isLearnPanning = false;
+                this.learnInitialTouchDist = Math.hypot(
+                    e.touches[0].clientX - e.touches[1].clientX,
+                    e.touches[0].clientY - e.touches[1].clientY
+                );
+                this.learnInitialScale = this.learnScale;
+            }
+        }, { passive: false });
+
+        overlay.addEventListener('touchmove', (e) => {
+            if (!this.isLearnMode) return;
+
+            // Allow drawing if 1 finger on canvas
+            if (e.target.closest('#learn-master-canvas') && e.touches.length === 1) return;
+
+            if (e.touches.length === 1 && this.isLearnPanning) {
+                if (e.cancelable) e.preventDefault();
+                const dx = e.touches[0].clientX - this.learnLastMouseX;
+                const dy = e.touches[0].clientY - this.learnLastMouseY;
+                this.learnOffsetX += dx;
+                this.learnOffsetY += dy;
+                this.learnLastMouseX = e.touches[0].clientX;
+                this.learnLastMouseY = e.touches[0].clientY;
+                this.applyLearnViewTransform();
+            } else if (e.touches.length === 2 && this.learnInitialTouchDist) {
+                if (e.cancelable) e.preventDefault();
+                const dist = Math.hypot(
+                    e.touches[0].clientX - e.touches[1].clientX,
+                    e.touches[0].clientY - e.touches[1].clientY
+                );
+                const zoomFactor = dist / this.learnInitialTouchDist;
+                this.learnScale = Math.min(Math.max(0.5, this.learnInitialScale * zoomFactor), 3.0);
+                this.applyLearnViewTransform();
+            }
+        }, { passive: false });
+
+        overlay.addEventListener('touchend', () => {
+            this.isLearnPanning = false;
+            this.learnInitialTouchDist = null;
+        });
+    }
+
+    applyLearnViewTransform() {
+        const content = document.querySelector('.learn-content');
+        if (content) {
+            content.style.transform = `translate(${this.learnOffsetX}px, ${this.learnOffsetY}px) scale(${this.learnScale})`;
+        }
     }
 
     setupQuizMode() {

commit 86c7e3fcbe57afac934c670d6262e2a3d535ed56
Author: galua2001 <galua2001@gmail.com>
Date:   Thu Feb 19 19:43:58 2026 +0900

    Initialize Unitess Gallery project

diff --git a/script.js b/script.js
new file mode 100644
index 0000000..27f6401
--- /dev/null
+++ b/script.js
@@ -0,0 +1,2776 @@
+class UnitessGalleryApp {
+    constructor() {
+        this.viewport = document.getElementById('gallery-viewport');
+        this.container = document.getElementById('gallery-container');
+        this.masterCanvas = document.getElementById('master-canvas');
+        this.masterCtx = this.masterCanvas.getContext('2d');
+
+        this.strokes = [];
+        this.learnStrokes = []; // ?숈뒿 紐⑤뱶 ?꾩슜 ?쒕줈??諛곗뿴 異붽?
+        this.isDrawing = false;
+
+        // View State (Zoom/Pan)
+        this.scale = 0.9; // ?쒖옉 ???붾㈃????苑?梨꾩슦?꾨줉 蹂寃?+        this.offsetX = 0;
+        this.offsetY = 0;
+        this.isPanning = false;
+        this.lastMouseX = 0;
+        this.lastMouseY = 0;
+
+        this.grids = [];
+        this.strokeWidth = 2;
+        this.masterStrokeColor = '#ff0000';
+        this.showLabels = true;
+        this.showCanvasGrid = true;
+        this.currentLang = 'ko';
+        this.currentPatternText = {
+            13: "?⑹꽦 蹂?섏쓣 ?듯빐 X異??移?臾대뒳瑜??뺤꽦?섎뒗 蹂듯빀 ?⑦꽩?낅땲??"
+        };
+
+        this.currentLearnRuleId = 1;
+        this.learnTiles = [];
+        this.isLearnMode = false;
+
+
+        this.i18n = {
+            en: {
+                menu_settings: "Settings",
+                menu_modes: "System Modes",
+                mode_square: "Square",
+                mode_triangle: "Triangle",
+                mode_hexagon: "Hexagon",
+                mode_quiz: "Quiz Game",
+                mode_learn: "Learn",
+                menu_stroke: "Stroke Style",
+                label_width: "Width",
+                label_color: "Color (Master)",
+                menu_view: "View",
+                btn_reset_view: "Reset View",
+                btn_toggle_labels: "Toggle Grid Labels",
+                btn_toggle_canvas_grid: "Toggle Canvas Grid",
+                menu_actions: "Actions",
+                btn_save_image: "Export Gallery PNG",
+                btn_clear: "Clear",
+                menu_learn: "Learn",
+                menu_appearance: "Appearance",
+                chat_title: "Community Chat",
+                chat_placeholder: "Talk about your design...",
+                label_tile_bg: "Tile Background",
+                btn_show_guide: "Guide",
+                btn_gallery_help: "Gallery Help",
+                alert_mode_ready: " Mode is being prepared!",
+                mode_falling: "Falling Game (Game 2)"
+            },
+            ko: {
+                menu_settings: "?ㅼ젙",
+                menu_modes: "?쒖뒪??紐⑤뱶",
+                mode_square: "?ш컖??,
+                mode_triangle: "?쇨컖??,
+                mode_hexagon: "?↔컖??,
+                mode_quiz: "?댁쫰寃뚯엫",
+                mode_learn: "?숈뒿",
+                menu_stroke: "釉뚮윭???ㅽ???,
+                label_width: "援듦린",
+                label_color: "?됱긽 (留덉뒪??",
+                menu_view: "蹂닿린 ?ㅼ젙",
+                btn_reset_view: "?붾㈃ 珥덇린??,
+                btn_toggle_labels: "?덉씠釉??좉?",
+                btn_toggle_canvas_grid: "?쒕줈??洹몃━???좉?",
+                menu_actions: "?묒뾽",
+                btn_save_image: "媛ㅻ윭由??대?吏 ???,
+                btn_clear: "吏?곌린",
+                menu_learn: "?꾩?留?,
+                menu_appearance: "?뚮쭏 ?ㅼ젙",
+                chat_title: "而ㅻ??덊떚 梨꾪똿",
+                chat_placeholder: "?묓뭹???????뷀빐蹂댁꽭??..",
+                label_tile_bg: "?ш컖??諛곌꼍??,
+                btn_show_guide: "?ㅻ챸",
+                btn_gallery_help: "媛ㅻ윭由??ㅻ챸",
+                alert_mode_ready: " Mode 以鍮?以묒엯?덈떎!",
+                mode_falling: "?숉븯 寃뚯엫 (Game 2)"
+            }
+        };
+
+        this.guideData = {
+            ko: {
+                title: "Unitess ?뚯??덉씠???대줎 媛?대뱶",
+                section1: {
+                    header: "8媛吏 蹂???쒖떆",
+                    symbols: ["T, C0", "C1", "C", "C3", "G(y)", "G(x)", "G(y=x)", "G(y=-x)"]
+                },
+                section2: {
+                    title: "?⑦꽩??醫낅쪟",
+                    text: "9媛吏 湲곕낯蹂?섎쭏??媛?대뜲 ?⑤쾲 ?ш컖??蹂??8媛吏, ?⑤쾲?ш컖??蹂???移?4媛吏, 利?8*4=32媛吏 以?以묐났?놁씠 媛?ν븳 ?⑦꽩??26媛吏媛 ?덈떎."
+                },
+                section3: {
+                    title: "?⑦꽩 CCGG(C1 y=x)?????ㅻ챸",
+                    desc1: "?욎쓽 C1? 媛?대뜲 ?⑤쾲 ?ш컖??蹂??,
+                    desc2: "?ㅼ쓽 y=x???⑤쾲?ш컖?뺤쓽 4蹂以?G蹂?섏뿉 ?대떦?섎뒗 蹂???ㅻ챸",
+                    formula1: "??C1, (?졻몼?™몿)=CCG(y=x)G(y=x)",
+                    desc3: "??C1???ш컖??4媛쒕??????蹂?섑몴??,
+                    desc4: "?댁썐???ш컖?뺣뱾??蹂??蹂???⑹꽦??寃곌낵",
+                    formula2: "(?ㅲ뫂)=C1*C*G(y=x)=G(x)",
+                    desc5: "?ㅻ뒗 C1(90???뚯쟾?쒗궓?? ?ㅼ떆 C(180???뚯쟾?쒗궓 寃???G(y=x) y=x異뺤뿉 ?곗묶?대룞?쒗궓 寃곌낵??x異??移?씠??",
+                    formula3: "(?β뫃)=C1*G(y=x)*G(y=x)=C1"
+                },
+                section4: {
+                    title: "?숈뒿 ??,
+                    tip: "??TTTT ?곹깭?먯꽌 ?ㅻⅨ 蹂??踰꾪듉???대┃?섎㈃ 媛?蹂?섏쓽 李⑥씠瑜???紐낇솗?섍쾶 ?뺤씤?????덉뒿?덈떎. (Hint: 蹂??鍮④컙 以묒젏???곌껐??怨≪꽑??洹몃젮蹂댁꽭??)"
+                },
+                galleryHelp: {
+                    title: "Unitess 媛ㅻ윭由??쒖슜 媛?대뱶",
+                    content: `
+                        <p class='modal-text'>?ш컖???덉쓽 以묒젏???뉖뒗 怨≪꽑??洹몃젮蹂댁꽭?? ?뚯쟾怨??移?씠 議고솕濡?쾶 ?댁슦?ъ쭊 26媛吏 ?뚯??덉씠???⑦꽩???꾨쫫?ㅼ???媛먯긽?섏떎 ???덉뒿?덈떎.</p>
+                        <p class='modal-text'>?ㅼ젙 硫붾돱瑜??듯빐 ?대? ???먯꽭??諛곗슦??<b>?숈뒿 紐⑤뱶</b>, ?щ??덈뒗 <b>寃뚯엫</b>, 洹몃━怨??뺤옣??<b>?쇨컖?뺢낵 ?↔컖??遺濡?媛ㅻ윭由?/b>??留뚮굹蹂댁꽭??</p>
+                        <p class='modal-text highlight-purple'>?먰븳 留뚮뱺 ?묓뭹????ν븯嫄곕굹 ??붿갹?먯꽌 ?ㅻⅨ ?ъ슜?먮뱾怨??먯쑀濡?쾶 ?댁빞湲곕? ?섎늻硫??곴컧??怨듭쑀?대낫?몄슂.</p>
+                    `
+                }
+            },
+            en: {
+                title: "Unitess Tessellation Theory Guide",
+                section1: {
+                    header: "8 Transformation Symbols",
+                    symbols: ["T, C0", "C1", "C", "C3", "G(y)", "G(x)", "G(y=x)", "G(y=-x)"]
+                },
+                section2: {
+                    title: "Types of Patterns",
+                    text: "For each of the 9 base transformations, there are 8 center (?? rotations and 4 edge symmetries. Out of 8*4=32 possibilities, 26 unique non-overlapping patterns exist."
+                },
+                section3: {
+                    title: "Example Explanation: CCGG(C1 y=x)",
+                    desc1: "The leading 'C1' refers to the center ??square transformation.",
+                    desc2: "The trailing 'y=x' describes the G-transformation applied to the 4 edges of square ??",
+                    formula1: "??C1, (?졻몼?™몿)=CCG(y=x)G(y=x)",
+                    desc3: "Symmetry markers for the 4 edges of square ??C1.",
+                    desc4: "Result of composite transformations of neighboring squares.",
+                    formula2: "(?ㅲ뫂)=C1*C*G(y=x)=G(x)",
+                    desc5: "??is the result of rotating 90째(C1), then 180째(C), followed by reflection across y=x (G(y=x)), resulting in X-axis symmetry.",
+                    formula3: "(?β뫃)=C1*G(y=x)*G(y=x)=C1"
+                },
+                section4: {
+                    title: "Learning Tip",
+                    tip: "??Clicking other transformation buttons starting from the TTTT state allows you to see the differences more clearly. (Hint: Try drawing a curve connecting the red midpoints of the sides!)"
+                },
+                galleryHelp: {
+                    title: "Unitess Gallery Guide",
+                    content: `
+                        <p class='modal-text'>Try drawing curves that connect the midpoints of the square. Discover the beauty of 26 unique tessellation patterns created through harmonious rotations and symmetries.</p>
+                        <p class='modal-text'>Explore the <b>Learn Mode</b>, play <b>Games</b>, or visit the expanded <b>Triangle and Hexagon appendix galleries</b> via the settings menu.</p>
+                        <p class='modal-text highlight-blue'>You can also save your patterns and share inspirations with others in the community chat.</p>
+                    `
+                }
+            }
+        };
+
+        this.isQuizMode = false;
+        this.quizScore = 0;
+        this.currentQuiz = null;
+
+        // 9? ?듭떖 ?移?洹몃９ ?뺤쓽
+        this.quizGroups = {
+            1: { name: "TTTT", label: "?됲뻾?대룞", symbol: "T", img: "symbol/TTTT.png", patterns: [1] },
+            2: { name: "CCCC", label: "?뚯쟾", symbol: "C", img: "symbol/CCCC.png", patterns: [2] },
+            3: { name: "C3C1C3C1", label: "蹂듯빀 ?뚯쟾", symbol: "C3C1", img: "symbol/C3C1C3C1(T).png", patterns: [3, 4] },
+            4: { name: "TCTC", label: "?대룞+?뚯쟾", symbol: "TC", img: "symbol/TCTC(T).png", patterns: [11, 12] },
+            5: { name: "TGTG", label: "?대룞+湲?쇱씠??, symbol: "TG", img: "symbol/tgtg(t x).png", patterns: [21, 22, 23, 24, 25, 26] },
+            6: { name: "CGCG", label: "?뚯쟾+湲?쇱씠??, symbol: "CG", img: "symbol/cgcg(T x).png", patterns: [13, 14, 15, 16] },
+            7: { name: "GGGG", label: "蹂듯빀 湲?쇱씠??, symbol: "GG", img: "symbol/gggg(T x).png", patterns: [7, 8, 9, 10] },
+            8: { name: "CCGG", label: "蹂듯빀 ?뚯쟾+?移?, symbol: "CCGG", img: "symbol/ccgg(T y=x).png", patterns: [17, 18, 19, 20] },
+            9: { name: "XYXY", label: "異??移?, symbol: "XY", img: "symbol/xyxy-A.png", patterns: [5, 6] }
+        };
+
+        // ?댁쫰 臾몄젣 ?곗씠??(?ㅼ젣 ?먯뀛 洹몃┝ ?뚯씪 留ㅼ묶)
+        this.quizData = [
+            { id: 1, escherNo: "Symmetry No.1", groupId: 1, img: "gameimage/tttt_1game.png", hint: "??諛⑺뼢?쇰줈 誘몃걚?ъ????대룞?섎뒗 媛??湲곕낯?곸씤 ?됲뻾?대룞 ?⑦꽩?낅땲??" },
+            { id: 2, escherNo: "Symmetry No.21", groupId: 2, img: "gameimage/cccc_1game.png", hint: "以묒떖?먯쓣 湲곗??쇰줈 ?щ갑???뚯쟾?섎ŉ 留욌Ъ由щ뒗 援ъ“?낅땲??" },
+            { id: 3, escherNo: "Symmetry No.3", groupId: 3, img: "gameimage/C3C1_1game.png", hint: "?쒕줈 ?ㅻⅨ ?뚯쟾 以묒떖???욎뿬 ?덈뒗 蹂듯빀 ?뚯쟾 ?⑦꽩?낅땲??" },
+            { id: 4, escherNo: "Symmetry No.11", groupId: 4, img: "gameimage/tctc_1game.png", hint: "?됲뻾?대룞怨??뚯쟾??議고솕濡?쾶 ?욎뿬 ?덉뒿?덈떎." },
+            { id: 5, escherNo: "Symmetry No.25", groupId: 5, img: "gameimage/tgtg_1game.png", hint: "?놁쑝濡??대룞?섎㈃???숈떆??諛섏궗(嫄곗슱)?섎뒗 湲?쇱씠???移?엯?덈떎." },
+            { id: 6, escherNo: "Symmetry No.45", groupId: 6, img: "gameimage/cgcg_1game.png", hint: "?뚯쟾怨?湲?쇱씠???移?씠 ?뺢탳?섍쾶 寃고빀?섏뼱 ?덉뒿?덈떎." },
+            { id: 7, escherNo: "Symmetry No.7", groupId: 7, img: "gameimage/gggg_1game.png", hint: "?щ윭 諛⑺뼢??湲?쇱씠???移?씠 蹂듯빀?곸쑝濡??섑??⑸땲??" },
+            { id: 8, escherNo: "Symmetry No.17", groupId: 8, img: "gameimage/ccgg_1game.png", hint: "?뚯쟾怨?諛섏궗媛 紐⑤몢 ?ы븿??媛??蹂듭옟?섍퀬 ?꾩꽦???믪? ?移?뎔?낅땲??" }
+        ];
+
+        // Game 2: Falling Squares State
+        this.isFallingGameMode = false;
+        this.fallingScore = 0;
+        this.lastSpawnTime = 0;
+        this.gameLoopActive = false;
+        this.isFallingPaused = false;
+        this.fallingLevel = 2; // Default: Normal
+        this.fallingSpeedBase = 1.0;
+
+        // Appendix Galleries State
+        this.triangleStrokes = [];
+        this.hexagonStrokes = [];
+        this.triangleGrids = [];
+        this.hexagonGrids = [];
+        this.appendixStrokeWidth = 3;
+
+        // Appendix Pattern Config (Colors matching the screenshot)
+        this.appendixColors = {
+            hex: [
+                '#e74c3c', '#e74c3c', '#e74c3c', '#e74c3c', '#e74c3c', // 1-5 Red
+                '#f1c40f', '#f1c40f', '#f1c40f', '#f1c40f', '#f1c40f', // 6-10 Yellow
+                '#2ecc71', '#2ecc71', '#2ecc71', '#2ecc71', '#2ecc71', // 11-15 Green
+                '#9b59b6', '#9b59b6', '#9b59b6', '#9b59b6', '#9b59b6', // 16-20 Purple
+                '#3498db', '#3498db'                                   // 21-22 Blue
+            ],
+            tri: [
+                '#000000', // 1 Black
+                '#3498db', '#3498db', '#3498db', // 2-4 Blue
+                '#e74c3c', '#e74c3c', '#e74c3c', '#e74c3c'  // 5-8 Red
+            ]
+        };
+
+        this.init();
+    }
+
+    init() {
+        this.setupMasterCanvas();
+        this.createGallery();
+        this.setupNavigation();
+        this.setupMenu();
+        this.setupChat();
+        this.setupLearnMode();
+        this.setupQuizMode();
+        this.setupFallingGameMode();
+        this.setupDrawingSystem();
+        this.updateLanguage();
+        this.setupAppendixGalleries();
+        this.applyViewTransform();
+        this.renderLoop();
+        this.applyViewTransform();
+        this.renderLoop();
+    }
+
+    setupMasterCanvas() {
+        const resize = () => {
+            const rect = this.masterCanvas.parentElement.getBoundingClientRect();
+            this.masterCanvas.width = rect.width;
+            this.masterCanvas.height = rect.height;
+            if (this.learnMasterCanvas) this.syncLearnCanvas();
+        };
+        window.addEventListener('resize', resize);
+        resize();
+    }
+
+    getSymbolById(gridId) {
+        if (gridId === 1) return 'TTTT';
+        if (gridId === 2) return 'CCCC';
+        if (gridId === 3 || gridId === 4) return 'C3C1*2';
+        if (gridId === 5 || gridId === 6) return 'XYXY';
+        if (gridId >= 7 && gridId <= 10) return 'GGGG';
+        if (gridId >= 11 && gridId <= 12) return 'TCTC';
+        if (gridId >= 13 && gridId <= 16) return 'CGCG';
+        if (gridId >= 17 && gridId <= 20) return 'CCGG';
+        if (gridId >= 21 && gridId <= 26) return 'TGTG';
+        return gridId;
+    }
+
+    createGallery() {
+        const layout = [];
+        for (let r = 0; r < 4; r++) { // 4?됱쑝濡?蹂寃?+            for (let c = 0; c < 7; c++) { // 7?대줈 蹂寃?+                if (r === 0 && c === 0) continue; // Skip master position
+                if (layout.length >= 26) break;   // Max 26 patterns
+                layout.push({ r, c });
+            }
+        }
+
+        layout.forEach((pos, index) => {
+            const gridId = index + 1; // Sequential 1-26 for grouping
+
+            const gridDiv = document.createElement('div');
+            gridDiv.className = `mini-grid grid-item col-${pos.c}`;
+            gridDiv.style.gridRow = pos.r + 1;
+            gridDiv.style.gridColumn = pos.c + 1;
+
+            // Add Pattern Label (Replacing Number)
+            const label = document.createElement('div');
+            label.className = 'grid-label';
+
+            let symbol = this.getSymbolById(gridId);
+            label.textContent = symbol;
+            gridDiv.appendChild(label);
+
+            const gridData = {
+                element: gridDiv,
+                tiles: [],
+                col: pos.c,
+                row: pos.r,
+                ruleSet: gridId,
+                symbol: symbol
+            };
+
+            // Create 6x6 tiles for each grid
+            for (let tr = 0; tr < 6; tr++) {
+                for (let tc = 0; tc < 6; tc++) {
+                    const tileDiv = document.createElement('div');
+                    tileDiv.className = 'mini-tile';
+                    const canvas = document.createElement('canvas');
+                    canvas.width = 50;
+                    canvas.height = 50;
+                    tileDiv.appendChild(canvas);
+                    gridDiv.appendChild(tileDiv);
+
+                    gridData.tiles.push({
+                        canvas: canvas,
+                        ctx: canvas.getContext('2d'),
+                        row: tr,
+                        col: tc,
+                        rule: this.getTileRule(gridData.ruleSet, tr, tc)
+                    });
+                }
+            }
+
+            this.container.appendChild(gridDiv);
+            this.grids.push(gridData);
+        });
+    }
+
+    getLearnTileRule(id, r, c) {
+        // ?ъ슜?먮떂猿섏꽌 二쇱떊 3x3 踰덊샇 泥닿퀎 留ㅽ븨
+        const mapping = [
+            [5, 4, 8],
+            [1, 9, 3],
+            [6, 2, 7]
+        ];
+        const num = mapping[r][c];
+
+        let type = 'T';
+
+        switch (id) {
+            case 2: { // CCCC
+                const c_list = [1, 2, 3, 4];
+                if (c_list.includes(num)) type = 'C';
+                else type = 'T';
+                break;
+            }
+            case 3: { // C3C1C3C1(0)
+                const c3_list = [1, 3];
+                const c1_list = [2, 4];
+                const c_list = [5, 6, 7, 8];
+                if (c3_list.includes(num)) type = 'C3';
+                else if (c1_list.includes(num)) type = 'C1';
+                else if (c_list.includes(num)) type = 'C';
+                else type = 'T';
+                break;
+            }
+            case 4: { // C3C1C3C1(90)
+                const t_list = [1, 3];
+                const c_list = [2, 4];
+                const c3_list = [5, 6, 7, 8];
+                if (t_list.includes(num)) type = 'T';
+                else if (c_list.includes(num)) type = 'C';
+                else if (c3_list.includes(num)) type = 'C3';
+                else if (num === 9) type = 'C1';
+                else type = 'T';
+                break;
+            }
+            case 5: { // XYXY-A
+                const c_list = [5, 6, 7, 8];
+                const x_list = [1, 3];
+                const y_list = [2, 4];
+                if (c_list.includes(num)) type = 'C';
+                else if (x_list.includes(num)) type = 'X';
+                else if (y_list.includes(num)) type = 'Y';
+                else type = 'T';
+                break;
+            }
+            case 6: { // XYXY-B
+                const c_list = [5, 6, 7, 8];
+                const y_list = [1, 3];
+                const x_list = [2, 4];
+                if (c_list.includes(num)) type = 'C';
+                else if (y_list.includes(num)) type = 'Y';
+                else if (x_list.includes(num)) type = 'X';
+                else type = 'T';
+                break;
+            }
+            case 7: { // GGGG(0 y=x)
+                const yx_list = [1, 2, 3, 4];
+                if (yx_list.includes(num)) type = 'Y=X';
+                else type = 'T';
+                break;
+            }
+            case 8: { // GGGG(0 y=-x)
+                const ynx_list = [1, 2, 3, 4];
+                if (ynx_list.includes(num)) type = 'Y=-X';
+                else type = 'T';
+                break;
+            }
+            case 9: { // GGGG(0 x)
+                const x_list = [1, 2, 3, 4];
+                if (x_list.includes(num)) type = 'X';
+                else type = 'T';
+                break;
+            }
+            case 10: { // GGGG(0 y)
+                const y_list = [1, 2, 3, 4];
+                if (y_list.includes(num)) type = 'Y';
+                else type = 'T';
+                break;
+            }
+            case 11: { // TCTC(0)
+                const c_list = [2, 4, 5, 6, 7, 8];
+                const t_list = [1, 3];
+                if (c_list.includes(num)) type = 'C';
+                else if (t_list.includes(num)) type = 'T';
+                else type = 'T';
+                break;
+            }
+            case 12: { // TCTC(90)
+                const c3_list = [2, 4, 5, 6, 7, 8];
+                const c1_list = [1, 3, 9];
+                if (c3_list.includes(num)) type = 'C3';
+                else if (c1_list.includes(num)) type = 'C1';
+                else type = 'T';
+                break;
+            }
+            case 13: { // CGCG (0 y)
+                const c_list = [1, 3];
+                const y_list = [2, 4];
+                const x_list = [5, 6, 7, 8];
+
+                if (c_list.includes(num)) type = 'C';
+                else if (y_list.includes(num)) type = 'Y';
+                else if (x_list.includes(num)) type = 'X';
+                else type = 'T'; // 9踰?留덉뒪??+                break;
+            }
+            case 14: { // CGCG (0 x)
+                const c_list = [1, 3];
+                const x_list = [2, 4];
+                const y_list = [5, 6, 7, 8];
+
+                if (c_list.includes(num)) type = 'C';
+                else if (x_list.includes(num)) type = 'X';
+                else if (y_list.includes(num)) type = 'Y';
+                else type = 'T';
+                break;
+            }
+            case 15: { // CGCG (90 x)
+                const c3_list = [1, 3];
+                const yx_list = [2, 4];
+                const ynx_list = [5, 6, 7, 8];
+
+                if (c3_list.includes(num)) type = 'C3';
+                else if (yx_list.includes(num)) type = 'Y=X';
+                else if (ynx_list.includes(num)) type = 'Y=-X';
+                else if (num === 9) type = 'C1';
+                else type = 'T';
+                break;
+            }
+            case 16: { // CGCG (90 y)
+                const c3_list = [1, 3];
+                const ynx_list = [2, 4];
+                const yx_list = [5, 6, 7, 8];
+
+                if (c3_list.includes(num)) type = 'C3';
+                else if (ynx_list.includes(num)) type = 'Y=-X';
+                else if (yx_list.includes(num)) type = 'Y=X';
+                else if (num === 9) type = 'C1';
+                else type = 'T';
+                break;
+            }
+            case 17: { // CCGG(0 y=x)
+                if ([1, 4].includes(num)) type = 'C';
+                else if ([2, 3].includes(num)) type = 'Y=X';
+                else if ([6, 8].includes(num)) type = 'T';
+                else if ([5, 7].includes(num)) type = 'Y=-X';
+                else type = 'T';
+                break;
+            }
+            case 18: { // CCGG(y y=x)
+                if ([1, 4].includes(num)) type = 'X';
+                else if ([2, 3].includes(num)) type = 'C1';
+                else if ([5, 7].includes(num)) type = 'C3';
+                else if ([6, 8, 9].includes(num)) type = 'Y';
+                else type = 'T';
+                break;
+            }
+            case 19: { // CCGG(90 y=x)
+                if ([1, 4].includes(num)) type = 'C3';
+                else if ([2, 3].includes(num)) type = 'Y';
+                else if ([5, 7].includes(num)) type = 'X';
+                else if ([6, 8, 9].includes(num)) type = 'C1';
+                else type = 'T';
+                break;
+            }
+            case 20: { // CCGG(y=x y=x)
+                if ([1, 4].includes(num)) type = 'Y=-X';
+                else if ([2, 3].includes(num)) type = 'T';
+                else if ([5, 7].includes(num)) type = 'C';
+                else if ([6, 8, 9].includes(num)) type = 'Y=X';
+                else type = 'T';
+                break;
+            }
+            case 21: { // TGTG(0 y=-x)
+                if ([1, 3, 9].includes(num)) type = 'T';
+                else type = 'Y=-X';
+                break;
+            }
+            case 22: { // TGTG(0 y=x)
+                if ([1, 3, 9].includes(num)) type = 'T';
+                else type = 'Y=X';
+                break;
+            }
+            case 23: { // TGTG(0 y)
+                if ([1, 3, 9].includes(num)) type = 'T';
+                else type = 'Y';
+                break;
+            }
+            case 24: { // TGTG(0 x)
+                if ([1, 3, 9].includes(num)) type = 'T';
+                else type = 'X';
+                break;
+            }
+            case 25: { // TGTG(90 x)
+                if ([1, 3, 9].includes(num)) type = 'C1';
+                else type = 'Y=X';
+                break;
+            }
+            case 26: { // TGTG(90 y)
+                if ([1, 3, 9].includes(num)) type = 'C1';
+                else type = 'Y=-X';
+                break;
+            }
+            default: {
+                if (num === 9) type = 'T';
+                else type = 'T';
+            }
+        }
+
+        const trans = this.getTransform(type);
+        return { rotation: trans.rotation, scaleX: trans.sx, scaleY: trans.sy };
+    }
+
+    getRuleForGrid(r, c, index) {
+        return index; // Simply use index 0-25
+    }
+
+    // 8媛吏 湲곕낯 蹂???뺤쓽 (?ъ슜???뺤쓽 湲고샇)
+    getTransform(type) {
+        switch (type) {
+            case 'T': return { rotation: 0, sx: 1, sy: 1 };    // 諛⑺뼢 (Identity)
+            case 'C': return { rotation: 180, sx: 1, sy: 1 };  // 180???뚯쟾
+            case 'C1': return { rotation: 90, sx: 1, sy: 1 };   // 90???뚯쟾
+            case 'C3': return { rotation: 270, sx: 1, sy: 1 };  // 270???뚯쟾
+            case 'X': return { rotation: 0, sx: 1, sy: -1 };   // ?곹븯 ?ㅼ쭛湲?+            case 'Y': return { rotation: 0, sx: -1, sy: 1 };   // 醫뚯슦 ?ㅼ쭛湲?+            case 'Y=X': return { rotation: 90, sx: -1, sy: 1 };  // ?媛곸꽑 ?移?+            case 'Y=-X': return { rotation: 270, sx: -1, sy: 1 }; // 諛섎? ?媛곸꽑 ?移?+            default: return { rotation: 0, sx: 1, sy: 1 };
+        }
+    }
+
+    getTileRule(id, r, c) {
+        // id: 1-26 (?ъ슜??吏??踰덊샇)
+        // r, c: 0-4 (5x5 洹몃━????醫뚰몴)
+        switch (id) {
+            case 1: // [1踰? ?덉떆: 紐⑤몢 T
+                const t1 = this.getTransform('T');
+                return { rotation: t1.rotation, scaleX: t1.sx, scaleY: t1.sy };
+
+            case 2: {
+                const num = r * 6 + c + 1;
+                let t2_type = 'C';
+                const t_list = [1, 3, 8, 13, 5, 10, 15, 20, 25, 12, 17, 22, 27, 32, 24, 29, 34, 36];
+                if (t_list.includes(num)) t2_type = 'T';
+                const t2 = this.getTransform(t2_type);
+                return { rotation: t2.rotation, scaleX: t2.sx, scaleY: t2.sy };
+            }
+
+            case 3: {
+                const num = r * 6 + c + 1;
+                let t3_type = 'T';
+                const c1_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const c_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const t_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const c3_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (c1_list.includes(num)) t3_type = 'C1';
+                else if (c_list.includes(num)) t3_type = 'C';
+                else if (t_list.includes(num)) t3_type = 'T';
+                else if (c3_list.includes(num)) t3_type = 'C3';
+
+                const t3 = this.getTransform(t3_type);
+                return { rotation: t3.rotation, scaleX: t3.sx, scaleY: t3.sy };
+            }
+            case 4: {
+                const num = r * 6 + c + 1;
+                let t4_type = 'T';
+                const c3_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const c_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const t_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const c1_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (c3_list.includes(num)) t4_type = 'C3';
+                else if (c_list.includes(num)) t4_type = 'C';
+                else if (t_list.includes(num)) t4_type = 'T';
+                else if (c1_list.includes(num)) t4_type = 'C1';
+
+                const t4 = this.getTransform(t4_type);
+                return { rotation: t4.rotation, scaleX: t4.sx, scaleY: t4.sy };
+            }
+            case 5: {
+                const num = r * 6 + c + 1;
+                let t5_type = 'T';
+                const x_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const c_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const t_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const y_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (x_list.includes(num)) t5_type = 'X';
+                else if (c_list.includes(num)) t5_type = 'C';
+                else if (t_list.includes(num)) t5_type = 'T';
+                else if (y_list.includes(num)) t5_type = 'Y';
+
+                const t5 = this.getTransform(t5_type);
+                return { rotation: t5.rotation, scaleX: t5.sx, scaleY: t5.sy };
+            }
+            case 6: {
+                const num = r * 6 + c + 1;
+                let t6_type = 'T';
+                const y_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const c_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const t_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const x_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (y_list.includes(num)) t6_type = 'Y';
+                else if (c_list.includes(num)) t6_type = 'C';
+                else if (t_list.includes(num)) t6_type = 'T';
+                else if (x_list.includes(num)) t6_type = 'X';
+
+                const t6 = this.getTransform(t6_type);
+                return { rotation: t6.rotation, scaleX: t6.sx, scaleY: t6.sy };
+            }
+            case 7: {
+                const num = r * 6 + c + 1;
+                let t7_type = 'T';
+                const yx_list = [1, 3, 8, 13, 5, 10, 15, 20, 25, 12, 17, 22, 27, 32, 24, 29, 34, 36];
+                if (yx_list.includes(num)) t7_type = 'Y=X';
+                const t7 = this.getTransform(t7_type);
+                return { rotation: t7.rotation, scaleX: t7.sx, scaleY: t7.sy };
+            }
+            case 8: {
+                const num = r * 6 + c + 1;
+                let t8_type = 'T';
+                const ynx_list = [1, 3, 8, 13, 5, 10, 15, 20, 25, 12, 17, 22, 27, 32, 24, 29, 34, 36];
+                if (ynx_list.includes(num)) t8_type = 'Y=-X';
+                const t8 = this.getTransform(t8_type);
+                return { rotation: t8.rotation, scaleX: t8.sx, scaleY: t8.sy };
+            }
+            case 9: {
+                const num = r * 6 + c + 1;
+                let t9_type = 'T';
+                const y_list = [1, 3, 8, 13, 5, 10, 15, 20, 25, 12, 17, 22, 27, 32, 24, 29, 34, 36];
+                if (y_list.includes(num)) t9_type = 'Y';
+                const t9 = this.getTransform(t9_type);
+                return { rotation: t9.rotation, scaleX: t9.sx, scaleY: t9.sy };
+            }
+            case 10: {
+                const num = r * 6 + c + 1;
+                let t10_type = 'T';
+                const x_list = [1, 3, 8, 13, 5, 10, 15, 20, 25, 12, 17, 22, 27, 32, 24, 29, 34, 36];
+                if (x_list.includes(num)) t10_type = 'X';
+                const t10 = this.getTransform(t10_type);
+                return { rotation: t10.rotation, scaleX: t10.sx, scaleY: t10.sy };
+            }
+            case 11: {
+                const num = r * 6 + c + 1;
+                let t11_type = 'T';
+                if ((num >= 1 && num <= 6) || (num >= 13 && num <= 18) || (num >= 25 && num <= 30)) {
+                    t11_type = 'C';
+                }
+                const t11 = this.getTransform(t11_type);
+                return { rotation: t11.rotation, scaleX: t11.sx, scaleY: t11.sy };
+            }
+            case 12: {
+                const num = r * 6 + c + 1;
+                let t12_type = 'C1';
+                if ((num >= 1 && num <= 6) || (num >= 13 && num <= 18) || (num >= 25 && num <= 30)) {
+                    t12_type = 'C3';
+                }
+                const t12 = this.getTransform(t12_type);
+                return { rotation: t12.rotation, scaleX: t12.sx, scaleY: t12.sy };
+            }
+            case 13: {
+                const num = r * 6 + c + 1;
+                let t13_type = 'T';
+                const ynx_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const yx_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const c1_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const c3_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (ynx_list.includes(num)) t13_type = 'Y=-X';
+                else if (yx_list.includes(num)) t13_type = 'Y=X';
+                else if (c1_list.includes(num)) t13_type = 'C1';
+                else if (c3_list.includes(num)) t13_type = 'C3';
+
+                const t13 = this.getTransform(t13_type);
+                return { rotation: t13.rotation, scaleX: t13.sx, scaleY: t13.sy };
+            }
+            case 14: {
+                const num = r * 6 + c + 1;
+                let t14_type = 'T';
+                const yx_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const ynx_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const c1_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const c3_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (yx_list.includes(num)) t14_type = 'Y=X';
+                else if (ynx_list.includes(num)) t14_type = 'Y=-X';
+                else if (c1_list.includes(num)) t14_type = 'C1';
+                else if (c3_list.includes(num)) t14_type = 'C3';
+
+                const t14 = this.getTransform(t14_type);
+                return { rotation: t14.rotation, scaleX: t14.sx, scaleY: t14.sy };
+            }
+            case 15: {
+                const num = r * 6 + c + 1;
+                let t15_type = 'T';
+                const y_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const x_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const t_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const c_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (y_list.includes(num)) t15_type = 'Y';
+                else if (x_list.includes(num)) t15_type = 'X';
+                else if (t_list.includes(num)) t15_type = 'T';
+                else if (c_list.includes(num)) t15_type = 'C';
+
+                const t15 = this.getTransform(t15_type);
+                return { rotation: t15.rotation, scaleX: t15.sx, scaleY: t15.sy };
+            }
+            case 16: {
+                const num = r * 6 + c + 1;
+                let t16_type = 'T';
+                const x_list = [1, 3, 5, 13, 15, 17, 25, 27, 29];
+                const y_list = [2, 4, 6, 14, 16, 18, 26, 28, 30];
+                const t_list = [7, 9, 11, 19, 21, 23, 31, 33, 35];
+                const c_list = [8, 10, 12, 20, 22, 24, 32, 34, 36];
+
+                if (x_list.includes(num)) t16_type = 'X';
+                else if (y_list.includes(num)) t16_type = 'Y';
+                else if (t_list.includes(num)) t16_type = 'T';
+                else if (c_list.includes(num)) t16_type = 'C';
+
+                const t16 = this.getTransform(t16_type);
+                return { rotation: t16.rotation, scaleX: t16.sx, scaleY: t16.sy };
+            }
+            case 17: {
+                const num = r * 6 + c + 1;
+                let t17_type = 'T';
+                const c3_list = [1, 5, 10, 15, 20, 25, 24, 29, 34, 35];
+                const c1_list = [2, 7, 6, 11, 16, 21, 26, 31, 30];
+                const y_list = [3, 8, 13, 12, 17, 22, 27, 32, 36];
+                const x_list = [4, 9, 14, 19, 18, 23, 28, 33];
+
+                if (c3_list.includes(num)) t17_type = 'C3';
+                else if (c1_list.includes(num)) t17_type = 'C1';
+                else if (y_list.includes(num)) t17_type = 'Y';
+                else if (x_list.includes(num)) t17_type = 'X';
+
+                const t17 = this.getTransform(t17_type);
+                return { rotation: t17.rotation, scaleX: t17.sx, scaleY: t17.sy };
+            }
+            case 18: {
+                const num = r * 6 + c + 1;
+                let t18_type = 'T';
+                const x_list = [1, 5, 10, 15, 20, 25, 24, 29, 34, 35];
+                const y_list = [2, 7, 6, 11, 16, 21, 26, 31, 30];
+                const c1_list = [3, 8, 13, 12, 17, 22, 27, 32, 36];
+                const c3_list = [4, 9, 14, 19, 18, 23, 28, 33];
+
+                if (x_list.includes(num)) t18_type = 'X';
+                else if (y_list.includes(num)) t18_type = 'Y';
+                else if (c1_list.includes(num)) t18_type = 'C1';
+                else if (c3_list.includes(num)) t18_type = 'C3';
+
+                const t18 = this.getTransform(t18_type);
+                return { rotation: t18.rotation, scaleX: t18.sx, scaleY: t18.sy };
+            }
+            case 19: {
+                const num = r * 6 + c + 1;
+                let t19_type = 'T';
+                const c_list = [1, 5, 10, 15, 20, 25, 24, 29, 34, 35];
+                const t_list = [2, 7, 6, 11, 16, 21, 26, 31, 30];
+                const yx_list = [3, 8, 13, 12, 17, 22, 27, 32, 36];
+                const ynx_list = [4, 9, 14, 19, 18, 23, 28, 33];
+
+                if (c_list.includes(num)) t19_type = 'C';
+                else if (t_list.includes(num)) t19_type = 'T';
+                else if (yx_list.includes(num)) t19_type = 'Y=X';
+                else if (ynx_list.includes(num)) t19_type = 'Y=-X';
+
+                const t19 = this.getTransform(t19_type);
+                return { rotation: t19.rotation, scaleX: t19.sx, scaleY: t19.sy };
+            }
+            case 20: {
+                const num = r * 6 + c + 1;
+                let t20_type = 'T';
+                const yx_list = [1, 5, 10, 15, 20, 25, 24, 29, 34, 35];
+                const t_list = [2, 7, 6, 11, 16, 21, 26, 31, 30];
+                const c_list = [3, 8, 13, 12, 17, 22, 27, 32, 36];
+                const ynx_list = [4, 9, 14, 19, 18, 23, 28, 33];
+
+                if (yx_list.includes(num)) t20_type = 'Y=X';
+                else if (t_list.includes(num)) t20_type = 'T';
+                else if (c_list.includes(num)) t20_type = 'C';
+                else if (ynx_list.includes(num)) t20_type = 'Y=-X';
+
+                const t20 = this.getTransform(t20_type);
+                return { rotation: t20.rotation, scaleX: t20.sx, scaleY: t20.sy };
+            }
+            case 21: {
+                const num = r * 6 + c + 1; // 1-36 踰덊샇 泥닿퀎
+                let t21_type = 'Y=-X'; // 湲곕낯媛?+
+                // ?ъ슜??吏???ы빆 諛섏쁺
+                if (num >= 19 && num <= 24) t21_type = 'T';
+                else if (num >= 25 && num <= 30) t21_type = 'Y=-X';
+                else if (num >= 31 && num <= 36) t21_type = 'T';
+                else {
+                    // 1~18踰덉? 湲곗〈??rr % 3 濡쒖쭅???쇨??깆쓣 ?꾪빐 ?좎? (rr=1????T)
+                    if ((r % 3) === 1) t21_type = 'T';
+                }
+
+                const t21 = this.getTransform(t21_type);
+                return { rotation: t21.rotation, scaleX: t21.sx, scaleY: t21.sy };
+            }
+            case 22: {
+                const num = r * 6 + c + 1;
+                let t22_type = 'Y=X';
+                if (num >= 19 && num <= 24) t22_type = 'T';
+                else if (num >= 25 && num <= 30) t22_type = 'Y=X';
+                else if (num >= 31 && num <= 36) t22_type = 'T';
+                else {
+                    if ((r % 3) === 1) t22_type = 'T';
+                }
+                const t22 = this.getTransform(t22_type);
+                return { rotation: t22.rotation, scaleX: t22.sx, scaleY: t22.sy };
+            }
+            case 23: {
+                const num = r * 6 + c + 1;
+                let t23_type = 'Y';
+                if (num >= 19 && num <= 24) t23_type = 'T';
+                else if (num >= 25 && num <= 30) t23_type = 'Y';
+                else if (num >= 31 && num <= 36) t23_type = 'T';
+                else {
+                    if ((r % 3) === 1) t23_type = 'T';
+                }
+                const t23 = this.getTransform(t23_type);
+                return { rotation: t23.rotation, scaleX: t23.sx, scaleY: t23.sy };
+            }
+            case 24: {
+                const num = r * 6 + c + 1;
+                let t24_type = 'X';
+                if (num >= 19 && num <= 24) t24_type = 'T';
+                else if (num >= 25 && num <= 30) t24_type = 'X';
+                else if (num >= 31 && num <= 36) t24_type = 'T';
+                else {
+                    if ((r % 3) === 1) t24_type = 'T';
+                }
+                const t24 = this.getTransform(t24_type);
+                return { rotation: t24.rotation, scaleX: t24.sx, scaleY: t24.sy };
+            }
+            case 25: {
+                const num = r * 6 + c + 1;
+                let t25_type = 'Y=X';
+                if (num >= 19 && num <= 24) t25_type = 'C1'; // 90
+                else if (num >= 25 && num <= 30) t25_type = 'Y=X';
+                else if (num >= 31 && num <= 36) t25_type = 'C1'; // 90
+                else {
+                    if ((r % 3) === 1) t25_type = 'C1';
+                }
+                const t25 = this.getTransform(t25_type);
+                return { rotation: t25.rotation, scaleX: t25.sx, scaleY: t25.sy };
+            }
+            case 26: // [26踰? 25踰??⑦꽩?먯꽌 Y=X瑜?Y=-X濡?蹂寃?(蹂듦뎄)
+                const num26 = r * 6 + c + 1;
+                let t26_type = 'Y=-X';
+                if ((num26 >= 1 && num26 <= 6) || (num26 >= 13 && num26 <= 18) || (num26 >= 25 && num26 <= 30)) {
+                    t26_type = 'C1';
+                }
+
+                const t26 = this.getTransform(t26_type);
+                return { rotation: t26.rotation, scaleX: t26.sx, scaleY: t26.sy };
+            default: return { rotation: 0, scaleX: 1, scaleY: 1 };
+        }
+    }
+
+    setupNavigation() {
+        // Zoom with Scroll (Desktop)
+        this.viewport.addEventListener('wheel', (e) => {
+            e.preventDefault();
+            const zoomSpeed = 0.001;
+            const delta = e.deltaY;
+            this.scale -= delta * zoomSpeed;
+            this.scale = Math.min(Math.max(0.1, this.scale), 3);
+            this.applyViewTransform();
+        }, { passive: false });
+
+        // Touch Variables for Mobile
+        let initialTouchDist = null;
+        let initialScale = 1;
+
+        // Pan with mouse (Desktop)
+        this.viewport.addEventListener('mousedown', (e) => {
+            if (e.target.closest('#master-square')) return; // Drawing area
+            this.isPanning = true;
+            this.lastMouseX = e.clientX;
+            this.lastMouseY = e.clientY;
+            this.viewport.style.cursor = 'grabbing';
+        });
+
+        // Touch Navigation (Mobile)
+        this.viewport.addEventListener('touchstart', (e) => {
+            // 留덉뒪??罹붾쾭?ㅻ굹 洹??먯떇 ?붿냼(?쒕줈???곸뿭) ?곗튂 ???대퉬寃뚯씠??以묐떒
+            if (e.target.closest('#master-square')) {
+                this.isPanning = false;
+                return;
+            }
+
+            if (e.touches.length === 1) {
+                this.isPanning = true;
+                this.lastMouseX = e.touches[0].clientX;
+                this.lastMouseY = e.touches[0].clientY;
+            } else if (e.touches.length === 2) {
+                this.isPanning = false;
+                initialTouchDist = Math.hypot(
+                    e.touches[0].clientX - e.touches[1].clientX,
+                    e.touches[0].clientY - e.touches[1].clientY
+                );
+                initialScale = this.scale;
+            }
+        }, { passive: false });
+
+        window.addEventListener('mousemove', (e) => {
+            if (this.isPanning) {
+                const dx = e.clientX - this.lastMouseX;
+                const dy = e.clientY - this.lastMouseY;
+                this.offsetX += dx;
+                this.offsetY += dy;
+                this.lastMouseX = e.clientX;
+                this.lastMouseY = e.clientY;
+                this.applyViewTransform();
+            }
+        });
+
+        window.addEventListener('touchmove', (e) => {
+            // ?쒕줈??以묒씠嫄곕굹 留덉뒪??罹붾쾭???꾨씪硫??대퉬寃뚯씠??臾댁떆
+            if (this.isDrawing || e.target.closest('#master-square')) return;
+
+            if (e.touches.length === 1 && this.isPanning) {
+                const dx = e.touches[0].clientX - this.lastMouseX;
+                const dy = e.touches[0].clientY - this.lastMouseY;
+                this.offsetX += dx;
+                this.offsetY += dy;
+                this.lastMouseX = e.touches[0].clientX;
+                this.lastMouseY = e.touches[0].clientY;
+                this.applyViewTransform();
+                if (e.cancelable) e.preventDefault();
+            } else if (e.touches.length === 2 && initialTouchDist) {
+                const currentDist = Math.hypot(
+                    e.touches[0].clientX - e.touches[1].clientX,
+                    e.touches[0].clientY - e.touches[1].clientY
+                );
+                const zoomFactor = currentDist / initialTouchDist;
+                this.scale = Math.min(Math.max(0.1, initialScale * zoomFactor), 4); // 理쒕? 以?4諛곕줈 ?뺤옣
+                this.applyViewTransform();
+                if (e.cancelable) e.preventDefault();
+            }
+        }, { passive: false });
+
+        window.addEventListener('mouseup', () => {
+            this.isPanning = false;
+            this.viewport.style.cursor = 'grab';
+        });
+
+        window.addEventListener('touchend', () => {
+            this.isPanning = false;
+            initialTouchDist = null;
+        });
+
+        this.viewport.addEventListener('contextmenu', e => e.preventDefault());
+    }
+
+    applyViewTransform() {
+        this.container.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
+    }
+
+    setupDrawingSystem() {
+        this.isDrawing = false;
+        this.strokes = [];
+
+        const getPos = (e) => {
+            const activeCanvas = this.isLearnMode ? this.learnMasterCanvas : this.masterCanvas;
+            if (!activeCanvas) return { x: 0, y: 0 };
+            const rect = activeCanvas.getBoundingClientRect();
+            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
+            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
+            return {
+                x: (clientX - rect.left) / rect.width,
+                y: (clientY - rect.top) / rect.height
+            };
+        };
+
+        const startDrawing = (e) => {
+            const activeCanvas = this.isLearnMode ? this.learnMasterCanvas : this.masterCanvas;
+            if (e.currentTarget !== activeCanvas) return;
+
+            if (e.type === 'mousedown' && e.button !== 0) return;
+            if (e.type === 'touchstart') e.preventDefault();
+
+            this.isDrawing = true;
+            const pos = getPos(e);
+            const targetStrokes = this.isLearnMode ? this.learnStrokes : this.strokes;
+            targetStrokes.push({ points: [pos] });
+        };
+
+        const moveDrawing = (e) => {
+            if (!this.isDrawing) return;
+            if (e.type === 'touchmove') e.preventDefault();
+            const pos = getPos(e);
+            const targetStrokes = this.isLearnMode ? this.learnStrokes : this.strokes;
+            targetStrokes[targetStrokes.length - 1].points.push(pos);
+        };
+
+        const stopDrawing = () => {
+            this.isDrawing = false;
+        };
+
+        this.masterCanvas.addEventListener('mousedown', startDrawing);
+        this.learnMasterCanvas.addEventListener('mousedown', startDrawing);
+        window.addEventListener('mousemove', moveDrawing);
+        window.addEventListener('mouseup', stopDrawing);
+
+        this.masterCanvas.addEventListener('touchstart', startDrawing, { passive: false });
+        this.learnMasterCanvas.addEventListener('touchstart', startDrawing, { passive: false });
+        window.addEventListener('touchmove', moveDrawing, { passive: false });
+        window.addEventListener('touchend', stopDrawing);
+
+        // Clear buttons
+        document.getElementById('floating-clear').onclick = (e) => {
+            e.stopPropagation();
+            this.strokes = [];
+        };
+        document.getElementById('learn-clear').onclick = (e) => {
+            e.stopPropagation();
+            this.learnStrokes = [];
+        };
+    }
+
+    renderLoop() {
+        this.masterCtx.clearRect(0, 0, this.masterCanvas.width, this.masterCanvas.height);
+        if (this.showCanvasGrid) this.drawCanvasGrid(this.masterCtx, this.masterCanvas.width, this.masterCanvas.height);
+        this.drawMidpointGuides(this.masterCtx, this.masterCanvas.width, this.masterCanvas.height);
+        this.drawStrokes(this.masterCtx, this.masterCanvas.width, this.masterCanvas.height, 'red');
+
+        // Learn Mode Render
+        if (this.isLearnMode) {
+            this.learnMasterCtx.clearRect(0, 0, this.learnMasterCanvas.width, this.learnMasterCanvas.height);
+            this.drawCanvasGrid(this.learnMasterCtx, this.learnMasterCanvas.width, this.learnMasterCanvas.height);
+            this.drawStrokes(this.learnMasterCtx, this.learnMasterCanvas.width, this.learnMasterCanvas.height, this.masterStrokeColor, true); // true for learnStrokes
+            this.drawMidpointGuides(this.learnMasterCtx, this.learnMasterCanvas.width, this.learnMasterCanvas.height);
+
+            const lerp = (c, t, f) => {
+                if (Math.abs(t - c) < 0.01) return t;
+                return c + (t - c) * f;
+            };
+            const f = 0.1; // Animation speed
+
+            this.learnTiles.forEach(tile => {
+                const ctx = tile.ctx;
+                const cw = tile.canvas.width;
+                const ch = tile.canvas.height;
+                ctx.clearRect(0, 0, cw, ch);
+
+                // Rotation wrap-around logic
+                let targetRot = tile.targetRule.rotation;
+                let currentRot = tile.rule.rotation;
+                let diff = targetRot - currentRot;
+                while (diff > 180) { targetRot -= 360; diff = targetRot - currentRot; }
+                while (diff < -180) { targetRot += 360; diff = targetRot - currentRot; }
+
+                tile.rule.rotation = lerp(currentRot, targetRot, f);
+                // Keep values within reasonable bounds
+                if (tile.rule.rotation > 360) tile.rule.rotation -= 360;
+                if (tile.rule.rotation < 0) tile.rule.rotation += 360;
+
+                tile.rule.scaleX = lerp(tile.rule.scaleX, tile.targetRule.scaleX, f);
+                tile.rule.scaleY = lerp(tile.rule.scaleY, tile.targetRule.scaleY, f);
+
+                ctx.save();
+                ctx.translate(cw / 2, ch / 2);
+                ctx.rotate(tile.rule.rotation * Math.PI / 180);
+                ctx.scale(tile.rule.scaleX, tile.rule.scaleY);
+                ctx.translate(-cw / 2, -ch / 2);
+                this.drawStrokes(ctx, cw, ch, '#fff', true); // true for learnStrokes
+                ctx.restore();
+            });
+        }
+
+        // Always render gallery grids in background or if not in learn mode
+        this.grids.forEach(grid => {
+            let groupColor = '#ffffff';
+            const id = grid.ruleSet;
+            if (id === 1) groupColor = '#FF5555';
+            else if (id === 2) groupColor = '#55FF55';
+            else if (id >= 3 && id <= 4) groupColor = '#5555FF';
+            else if (id >= 5 && id <= 6) groupColor = '#FFFF55';
+            else if (id >= 7 && id <= 10) groupColor = '#FF55FF';
+            else if (id >= 11 && id <= 12) groupColor = '#55FFFF';
+            else if (id >= 13 && id <= 16) groupColor = '#FFAA00';
+            else if (id >= 17 && id <= 20) groupColor = '#AA55FF';
+            else if (id >= 21 && id <= 26) groupColor = '#00FF99';
+
+            grid.tiles.forEach(tile => {
+                const ctx = tile.ctx;
+                const cw = tile.canvas.width;
+                const ch = tile.canvas.height;
+                ctx.clearRect(0, 0, cw, ch);
+                ctx.save();
+                ctx.translate(cw / 2, ch / 2);
+                ctx.rotate(tile.rule.rotation * Math.PI / 180);
+                ctx.scale(tile.rule.scaleX, tile.rule.scaleY);
+                ctx.translate(-cw / 2, -ch / 2);
+                this.drawStrokes(ctx, cw, ch, groupColor);
+                ctx.restore();
+            });
+        });
+
+        requestAnimationFrame(() => this.renderLoop());
+    }
+
+    setupMenu() {
+        const menu = document.getElementById('side-menu');
+        const toggleBtn = document.getElementById('menu-toggle');
+        const closeBtn = document.getElementById('close-menu');
+
+        toggleBtn.onclick = () => menu.classList.toggle('hidden');
+        closeBtn.onclick = () => menu.classList.add('hidden');
+
+        // Close menu on ESC
+        window.addEventListener('keydown', (e) => {
+            if (e.key === 'Escape') menu.classList.add('hidden');
+        });
+
+        // System Modes Navigation
+        const modeCards = document.querySelectorAll('.mode-card');
+        modeCards.forEach(card => {
+            card.onclick = () => {
+                modeCards.forEach(c => c.classList.remove('active'));
+                card.classList.add('active');
+
+                const mode = card.dataset.mode;
+                console.log(`Navigating to ${mode} mode...`);
+
+                // Placeholder for actual navigation or module loading
+                // Learn Mode Activation
+                if (mode === 'learn') {
+                    this.isLearnMode = true;
+                    document.getElementById('learn-mode-overlay').classList.remove('hidden');
+                    this.syncLearnCanvas();
+                } else if (mode === 'quiz') {
+                    this.isQuizMode = true;
+                    this.startNewQuiz();
+                    document.getElementById('quiz-mode-overlay').classList.remove('hidden');
+                } else if (mode === 'triangle') {
+                    document.getElementById('triangle-gallery-overlay').classList.remove('hidden');
+                    this.syncAppendixCanvases('triangle');
+                } else if (mode === 'hexagon') {
+                    document.getElementById('hexagon-gallery-overlay').classList.remove('hidden');
+                    this.syncAppendixCanvases('hexagon');
+                } else if (mode === 'falling') {
+                    this.startFallingGame();
+                } else if (mode !== 'square') {
+                    alert(`${mode.charAt(0).toUpperCase() + mode.slice(1)} ${this.i18n[this.currentLang].alert_mode_ready}`);
+                }
+            };
+        });
+
+        const exitLearn = document.getElementById('exit-learn');
+        if (exitLearn) exitLearn.onclick = () => {
+            this.isLearnMode = false;
+            document.getElementById('learn-mode-overlay').classList.add('hidden');
+        };
+
+        const exitTriangle = document.getElementById('exit-triangle');
+        if (exitTriangle) exitTriangle.onclick = () => {
+            document.getElementById('triangle-gallery-overlay').classList.add('hidden');
+        };
+
+        const exitHexagon = document.getElementById('exit-hexagon');
+        if (exitHexagon) exitHexagon.onclick = () => {
+            document.getElementById('hexagon-gallery-overlay').classList.add('hidden');
+        };
+
+        const exitQuiz = document.getElementById('exit-quiz');
+        if (exitQuiz) exitQuiz.onclick = () => {
+            this.isQuizMode = false;
+            document.getElementById('quiz-mode-overlay').classList.add('hidden');
+        };
+
+        const exitFalling = document.getElementById('exit-falling');
+        if (exitFalling) exitFalling.onclick = () => {
+            this.stopFallingGame();
+        };
+
+
+        // Stroke Style
+        document.getElementById('lineWidth').oninput = (e) => {
+            this.strokeWidth = parseInt(e.target.value);
+        };
+        document.getElementById('strokeColor').oninput = (e) => {
+            this.masterStrokeColor = e.target.value;
+        };
+
+        // View Controls
+        document.getElementById('reset-view').onclick = () => {
+            this.scale = 0.9;
+            this.offsetX = 0;
+            this.offsetY = 0;
+            this.applyViewTransform();
+        };
+
+        document.getElementById('toggle-grid').onclick = () => {
+            this.showLabels = !this.showLabels;
+            document.body.classList.toggle('labels-hidden', !this.showLabels);
+        };
+
+        document.getElementById('toggle-canvas-grid').onclick = () => {
+            this.showCanvasGrid = !this.showCanvasGrid;
+        };
+
+        // Appearance
+        document.getElementById('tileBgColor').oninput = (e) => {
+            document.documentElement.style.setProperty('--tile-bg', e.target.value);
+            // Master square is also white by default, let's update it too
+            document.querySelector('.master-square').style.backgroundColor = e.target.value;
+        };
+
+        // Actions
+        document.getElementById('save-btn').onclick = () => {
+            this.saveGalleryImage();
+        };
+
+        // Floating Clear Button (Moved to setupDrawingSystem)
+
+        // Language Selection
+        document.getElementById('lang-select').onchange = (e) => {
+            this.currentLang = e.target.value;
+            this.updateLanguage();
+        };
+
+        // Gallery Guide Button
+        const galleryHelpBtn = document.getElementById('gallery-guide-btn');
+        if (galleryHelpBtn) {
+            galleryHelpBtn.onclick = () => this.showGalleryHelp();
+        }
+    }
+
+    setupChat() {
+        const chatPanel = document.getElementById('chat-panel');
+        const chatToggle = document.getElementById('chat-toggle');
+        const closeChat = document.getElementById('close-chat');
+        const chatInput = document.getElementById('chat-input');
+        const sendBtn = document.getElementById('send-chat');
+        const shareBtn = document.getElementById('share-canvas');
+
+        chatToggle.onclick = () => chatPanel.classList.toggle('chat-hidden');
+        closeChat.onclick = () => chatPanel.classList.add('chat-hidden');
+
+        const sendMessage = () => {
+            const text = chatInput.value.trim();
+            if (!text) return;
+
+            // Add user message to UI
+            this.appendMessage('sent', text);
+            chatInput.value = '';
+        };
+
+        const shareDrawing = () => {
+            const dataUrl = this.masterCanvas.toDataURL();
+            this.appendMessage('sent', '', dataUrl);
+        };
+
+        sendBtn.onclick = sendMessage;
+        shareBtn.onclick = shareDrawing;
+        chatInput.onkeypress = (e) => { if (e.key === 'Enter') sendMessage(); };
+    }
+
+    appendMessage(type, text, imageUrl = null) {
+        const container = document.getElementById('chat-messages');
+        const msgDiv = document.createElement('div');
+        msgDiv.className = `message ${type}`;
+
+        if (text) {
+            const textSpan = document.createElement('span');
+            textSpan.textContent = text;
+            msgDiv.appendChild(textSpan);
+        }
+
+        if (imageUrl) {
+            const img = document.createElement('img');
+            img.src = imageUrl;
+            msgDiv.appendChild(img);
+        }
+
+        container.appendChild(msgDiv);
+        container.scrollTop = container.scrollHeight;
+    }
+
+    updateLanguage() {
+        const langData = this.i18n[this.currentLang];
+        document.querySelectorAll('[data-i18n]').forEach(el => {
+            const key = el.dataset.i18n;
+            if (langData[key]) {
+                el.textContent = langData[key];
+            }
+        });
+    }
+
+    saveGalleryImage() {
+        const gridSize = 400; // Size per pattern (high res)
+        const gap = 20;       // Gap between patterns
+        const cols = 7;
+        const rows = 4;
+        const tileSize = gridSize / 6;
+
+        const exportCanvas = document.createElement('canvas');
+        exportCanvas.width = cols * gridSize + (cols - 1) * gap + 40;
+        exportCanvas.height = rows * gridSize + (rows - 1) * gap + 40;
+        const eCtx = exportCanvas.getContext('2d');
+
+        // 1. Fill entire background
+        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim() || '#f1f8e9';
+        eCtx.fillStyle = bgColor;
+        eCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
+
+        const tileBg = getComputedStyle(document.documentElement).getPropertyValue('--tile-bg').trim() || '#ffffff';
+
+        // 2. Draw Master Drawing (at position 0,0)
+        const masterX = 20;
+        const masterY = 20;
+        eCtx.fillStyle = tileBg;
+        eCtx.fillRect(masterX, masterY, gridSize, gridSize);
+
+        eCtx.save();
+        eCtx.translate(masterX, masterY);
+        const masterScale = gridSize / this.masterCanvas.width;
+        eCtx.scale(masterScale, masterScale);
+        this.drawStrokes(eCtx, this.masterCanvas.width, this.masterCanvas.height, this.masterStrokeColor);
+        eCtx.restore();
+
+        // 3. Draw 26 patterns
+        this.grids.forEach(grid => {
+            const gx = 20 + grid.col * (gridSize + gap);
+            const gy = 20 + grid.row * (gridSize + gap);
+
+            // Determine pattern group color
+            let groupColor = '#ffffff';
+            const id = grid.ruleSet;
+            if (id === 1) groupColor = '#FF5555';
+            else if (id === 2) groupColor = '#55FF55';
+            else if (id >= 3 && id <= 4) groupColor = '#5555FF';
+            else if (id >= 5 && id <= 6) groupColor = '#FFFF55';
+            else if (id >= 7 && id <= 10) groupColor = '#FF55FF';
+            else if (id >= 11 && id <= 12) groupColor = '#55FFFF';
+            else if (id >= 13 && id <= 16) groupColor = '#FFAA00';
+            else if (id >= 17 && id <= 20) groupColor = '#AA55FF';
+            else if (id >= 21 && id <= 26) groupColor = '#00FF99';
+
+            // Tile background
+            eCtx.fillStyle = tileBg;
+            eCtx.fillRect(gx, gy, gridSize, gridSize);
+
+            // Draw 6x6 tiles for this pattern
+            grid.tiles.forEach(tile => {
+                const tx = gx + tile.col * tileSize;
+                const ty = gy + tile.row * tileSize;
+
+                eCtx.save();
+                eCtx.translate(tx + tileSize / 2, ty + tileSize / 2);
+                eCtx.rotate(tile.rule.rotation * Math.PI / 180);
+                eCtx.scale(tile.rule.scaleX, tile.rule.scaleY);
+                eCtx.translate(-tileSize / 2, -tileSize / 2);
+
+                // Draw strokes for this tile
+                this.drawStrokes(eCtx, tileSize, tileSize, groupColor);
+                eCtx.restore();
+            });
+
+            // Optional: Draw pattern label
+            if (this.showLabels) {
+                eCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
+                // Reduced font size slightly for long symbols
+                eCtx.font = `bold ${gridSize * 0.08}px sans-serif`;
+                eCtx.textAlign = 'center';
+                eCtx.fillText(grid.symbol, gx + gridSize / 2, gy + gridSize / 2 + 10);
+            }
+        });
+
+    }
+
+    explanationData = {
+        1: {
+            ko: { title: "TTTT", text: "", imageHTML: `<img src="symbol/TTTT.png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TTTT", text: "", imageHTML: `<img src="symbol/TTTT.png?v=${Date.now()}" alt="Diagram">` }
+        },
+        2: {
+            ko: { title: "CCCC", text: "", imageHTML: `<img src="symbol/CCCC.png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CCCC", text: "", imageHTML: `<img src="symbol/CCCC.png?v=${Date.now()}" alt="Diagram">` }
+        },
+        3: {
+            ko: { title: "C3C1C3C1(T)", text: "", imageHTML: `<img src="symbol/C3C1C3C1(T).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "C3C1C3C1(T)", text: "", imageHTML: `<img src="symbol/C3C1C3C1(T).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        4: {
+            ko: { title: "C3C1C3C1(C1)", text: "", imageHTML: `<img src="symbol/C3C1C3C1(C1).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "C3C1C3C1(C1)", text: "", imageHTML: `<img src="symbol/C3C1C3C1(C1).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        11: {
+            ko: { title: "TCTC(T)", text: "", imageHTML: `<img src="symbol/TCTC(T).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TCTC(T)", text: "", imageHTML: `<img src="symbol/TCTC(T).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        12: {
+            ko: { title: "TCTC(C1)", text: "", imageHTML: `<img src="symbol/TCTC(C1).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TCTC(C1)", text: "", imageHTML: `<img src="symbol/TCTC(C1).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        5: {
+            ko: { title: "XYXY-A", text: "", imageHTML: `<img src="symbol/xyxy-A.png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "XYXY-A", text: "", imageHTML: `<img src="symbol/xyxy-A.png?v=${Date.now()}" alt="Diagram">` }
+        },
+        6: {
+            ko: { title: "XYXY-B", text: "", imageHTML: `<img src="symbol/xyxy-B.png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "XYXY-B", text: "", imageHTML: `<img src="symbol/xyxy-B.png?v=${Date.now()}" alt="Diagram">` }
+        },
+        13: {
+            ko: { title: "CGCG (T y)", text: "", imageHTML: `<img src="symbol/cgcg(T%20y).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CGCG (T y)", text: "", imageHTML: `<img src="symbol/cgcg(T%20y).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        14: {
+            ko: { title: "CGCG (T x)", text: "", imageHTML: `<img src="symbol/cgcg(T%20x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CGCG (T x)", text: "", imageHTML: `<img src="symbol/cgcg(T%20x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        15: {
+            ko: { title: "CGCG (C1 x)", text: "", imageHTML: `<img src="symbol/cgcg(C1%20x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CGCG (C1 x)", text: "", imageHTML: `<img src="symbol/cgcg(C1%20x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        16: {
+            ko: { title: "CGCG (C1 y)", text: "", imageHTML: `<img src="symbol/cgcg(C1%20y=-x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CGCG (C1 y)", text: "", imageHTML: `<img src="symbol/cgcg(C1%20y=-x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        7: {
+            ko: { title: "GGGG(T y=x)", text: "", imageHTML: `<img src="symbol/gggg(T%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "GGGG(T y=x)", text: "", imageHTML: `<img src="symbol/gggg(T%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        8: {
+            ko: { title: "GGGG(T y=-x)", text: "", imageHTML: `<img src="symbol/gggg(T%20y=-x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "GGGG(T y=-x)", text: "", imageHTML: `<img src="symbol/gggg(T%20y=-x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        9: {
+            ko: { title: "GGGG(T x)", text: "", imageHTML: `<img src="symbol/gggg(T%20x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "GGGG(T x)", text: "", imageHTML: `<img src="symbol/gggg(T%20x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        10: {
+            ko: { title: "GGGG(T y)", text: "", imageHTML: `<img src="symbol/gggg(T%20y).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "GGGG(T y)", text: "", imageHTML: `<img src="symbol/gggg(T%20y).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        21: {
+            ko: { title: "TGTG(T y=-x)", text: "", imageHTML: `<img src="symbol/tgtg(t%20y=-x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TGTG(T y=-x)", text: "", imageHTML: `<img src="symbol/tgtg(t%20y=-x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        22: {
+            ko: { title: "TGTG(T y=x)", text: "", imageHTML: `<img src="symbol/tgtg(t%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TGTG(T y=x)", text: "", imageHTML: `<img src="symbol/tgtg(t%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        23: {
+            ko: { title: "TGTG(T y)", text: "", imageHTML: `<img src="symbol/tgtg(t%20y).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TGTG(T y)", text: "", imageHTML: `<img src="symbol/tgtg(t%20y).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        24: {
+            ko: { title: "TGTG(T x)", text: "", imageHTML: `<img src="symbol/tgtg(t%20x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TGTG(T x)", text: "", imageHTML: `<img src="symbol/tgtg(t%20x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        25: {
+            ko: { title: "TGTG(C1 x)", text: "", imageHTML: `<img src="symbol/tgtg(C1%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TGTG(C1 x)", text: "", imageHTML: `<img src="symbol/tgtg(C1%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        26: {
+            ko: { title: "TGTG(C1 y)", text: "", imageHTML: `<img src="symbol/tgtg(C1%20y=-x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "TGTG(C1 y)", text: "", imageHTML: `<img src="symbol/tgtg(C1%20y=-x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        17: {
+            ko: { title: "CCGG(T y=x)", text: "", imageHTML: `<img src="symbol/ccgg(T%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CCGG(T y=x)", text: "", imageHTML: `<img src="symbol/ccgg(T%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        18: {
+            ko: { title: "CCGG(y y=x)", text: "", imageHTML: `<img src="symbol/ccgg(y%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CCGG(y y=x)", text: "", imageHTML: `<img src="symbol/ccgg(y%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        19: {
+            ko: { title: "CCGG(C1 y=x)", text: "", imageHTML: `<img src="symbol/ccgg(C1%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CCGG(C1 y=x)", text: "", imageHTML: `<img src="symbol/ccgg(C1%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        },
+        20: {
+            ko: { title: "CCGG(y=x y=x)", text: "", imageHTML: `<img src="symbol/ccgg(y=x%20y=x).png?v=${Date.now()}" alt="Diagram">` },
+            en: { title: "CCGG(y=x y=x)", text: "", imageHTML: `<img src="symbol/ccgg(y=x%20y=x).png?v=${Date.now()}" alt="Diagram">` }
+        }
+    };
+
+    openModal(title, bodyHTML) {
+        document.getElementById('modal-title').textContent = title;
+        document.getElementById('modal-body').innerHTML = bodyHTML;
+        document.getElementById('explanation-modal').classList.remove('hidden');
+    }
+
+    closeModal() {
+        document.getElementById('explanation-modal').classList.add('hidden');
+    }
+
+    showPatternExplain(id) {
+        const lang = this.currentLang;
+        const data = this.explanationData[id] ? this.explanationData[id][lang] : null;
+        const panel = document.getElementById('pattern-detail-panel');
+        const titleEl = document.getElementById('detail-title');
+        const contentEl = document.getElementById('detail-content');
+
+        if (!data) {
+            panel.classList.add('detail-hidden');
+            return;
+        }
+
+        titleEl.textContent = data.title;
+        contentEl.innerHTML = `
+            ${data.imageHTML || ''}
+            <div class="detail-text">${data.text || ''}</div>
+        `;
+        panel.classList.remove('detail-hidden');
+    }
+
+    showGalleryHelp() {
+        const lang = this.currentLang;
+        const data = this.guideData[lang].galleryHelp;
+        this.openModal(data.title, data.content);
+    }
+
+    showGeneralGuide() {
+        const lang = this.currentLang;
+        const data = this.guideData[lang];
+        const title = data.title;
+
+        let html = `
+            <div class="guide-container">
+                <div class="modal-section symbol-table-section">
+                    <h3>${data.section1.header}</h3>
+                    <div class="symbol-grid-wrapper">
+                        <img src="symbol/explain_1.png?v=${Date.now()}" class="guide-bg-image" alt="Symbols Diagram">
+                    </div>
+                </div>
+
+                <div class="guide-two-col">
+                    <div class="modal-section">
+                        <h3>${data.section2.title}</h3>
+                        <p class="modal-text">${data.section2.text}</p>
+                        <div class="pattern-types-img">
+                            <img src="symbol/explain_2.png?v=${Date.now()}" class="guide-bg-image" alt="Pattern Grid">
+                        </div>
+                    </div>
+                    <div class="modal-section">
+                        <h3>${data.section3.title}</h3>
+                        <p class="modal-text highlight-red">${data.section3.desc1}</p>
+                        <p class="modal-text highlight-red">${data.section3.desc2}</p>
+                        <div class="modal-formula">${data.section3.formula1}</div>
+                        <p class="modal-text highlight-red">${data.section3.desc3}</p>
+                        
+                        <p class="modal-text highlight-purple">${data.section3.desc4}</p>
+                        <div class="modal-formula">${data.section3.formula2}</div>
+                        <p class="modal-text small-desc">${data.section3.desc5}</p>
+                        <div class="modal-formula">${data.section3.formula3}</div>
+                    </div>
+                </div>
+
+                <div class="modal-section tip-section">
+                    <h3>${data.section4.title}</h3>
+                    <p class="modal-text"><b>${data.section4.tip}</b></p>
+                </div>
+            </div>
+        `;
+        this.openModal(title, html);
+    }
+
+    setupLearnMode() {
+        this.learnMasterCanvas = document.getElementById('learn-master-canvas');
+        this.learnMasterCtx = this.learnMasterCanvas.getContext('2d');
+        const previewGrid = document.getElementById('preview-grid-3x3');
+
+        // Initialize 3x3 Preview Tiles
+        for (let r = 0; r < 3; r++) {
+            for (let c = 0; c < 3; c++) {
+                const tileDiv = document.createElement('div');
+                tileDiv.className = 'preview-tile';
+                const canvas = document.createElement('canvas');
+                canvas.width = 150;
+                canvas.height = 150;
+                tileDiv.appendChild(canvas);
+                previewGrid.appendChild(tileDiv);
+
+                const rule = this.getLearnTileRule(this.currentLearnRuleId, r, c);
+                this.learnTiles.push({
+                    canvas: canvas,
+                    ctx: canvas.getContext('2d'),
+                    row: r,
+                    col: c,
+                    rule: { ...rule }, // Initial state
+                    targetRule: { ...rule } // Target state for animation
+                });
+            }
+        }
+
+        // Rule Selection Logic
+        const ruleBtns = document.querySelectorAll('.rule-btn');
+        ruleBtns.forEach(btn => {
+            btn.onclick = () => {
+                ruleBtns.forEach(b => b.classList.remove('active'));
+                btn.classList.add('active');
+
+                this.currentLearnRuleId = parseInt(btn.dataset.id);
+                document.getElementById('current-pattern-id').textContent = btn.textContent;
+                // Update target rule for animation
+                this.learnTiles.forEach(tile => {
+                    tile.targetRule = this.getLearnTileRule(this.currentLearnRuleId, tile.row, tile.col);
+                });
+            };
+        });
+
+        // Info/Popup Buttons Logic
+        const infoBtns = document.querySelectorAll('.info-btn');
+        infoBtns.forEach(btn => {
+            btn.onclick = (e) => {
+                e.stopPropagation();
+                const id = parseInt(btn.dataset.id);
+                this.showPatternExplain(id);
+            };
+        });
+
+        // Modal/Guide Controls
+        document.getElementById('show-general-explain').onclick = () => this.showGeneralGuide();
+        document.getElementById('close-modal').onclick = () => this.closeModal();
+        document.getElementById('close-detail').onclick = () => {
+            document.getElementById('pattern-detail-panel').classList.add('detail-hidden');
+        };
+        window.onclick = (e) => {
+            if (e.target === document.getElementById('explanation-modal')) this.closeModal();
+        };
+
+        // Initial text display
+        const activeBtn = document.querySelector('.rule-btn.active');
+        if (activeBtn) document.getElementById('current-pattern-id').textContent = activeBtn.textContent;
+    }
+
+    setupQuizMode() {
+        const optionsContainer = document.getElementById('quiz-options-container');
+        if (!optionsContainer) return;
+
+        optionsContainer.innerHTML = '';
+        optionsContainer.className = 'quiz-grid-9';
+
+        this.quizButtonCanvases = [];
+
+        Object.keys(this.quizGroups).forEach(groupId => {
+            const group = this.quizGroups[groupId];
+            const card = document.createElement('div');
+            card.className = 'quiz-group-card';
+
+            const canvas = document.createElement('canvas');
+            canvas.width = 120;
+            canvas.height = 120;
+            canvas.className = 'quiz-button-canvas';
+
+            card.innerHTML = `
+                <div class="group-img-wrapper">
+                    <!-- Canvas will be appended here -->
+                </div>
+                <div class="group-info">
+                    <span class="group-name">${group.name}</span>
+                    <span class="group-symbol">${group.symbol}</span>
+                </div>
+            `;
+
+            const wrapper = card.querySelector('.group-img-wrapper');
+            wrapper.appendChild(canvas);
+
+            this.quizButtonCanvases.push({
+                groupId: parseInt(groupId),
+                canvas: canvas,
+                ctx: canvas.getContext('2d')
+            });
+
+            card.onclick = () => this.checkQuizAnswer(parseInt(groupId));
+            optionsContainer.appendChild(card);
+        });
+
+        this.renderQuizButtons();
+    }
+
+    renderQuizButtons() {
+        if (!this.quizButtonCanvases) return;
+
+        const strokesToDraw = JSON.parse(JSON.stringify(this.learnStrokes));
+
+        this.quizButtonCanvases.forEach(item => {
+            const group = this.quizGroups[item.groupId];
+            const ctx = item.ctx;
+            const cw = item.canvas.width;
+            const ch = item.canvas.height;
+            const tileSize = cw / 3;
+
+            ctx.clearRect(0, 0, cw, ch);
+            ctx.fillStyle = "#ffffff";
+            ctx.fillRect(0, 0, cw, ch);
+
+            const samplePatternId = group.patterns[0];
+
+            // Draw 3x3 Grid
+            for (let r = 0; r < 3; r++) {
+                for (let c = 0; c < 3; c++) {
+                    const rule = this.getLearnTileRule(samplePatternId, r, c);
+                    const tx = c * tileSize;
+                    const ty = r * tileSize;
+
+                    ctx.save();
+                    ctx.translate(tx + tileSize / 2, ty + tileSize / 2);
+                    ctx.rotate(rule.rotation * Math.PI / 180);
+                    ctx.scale(rule.scaleX, rule.scaleY);
+                    ctx.translate(-tileSize / 2, -tileSize / 2);
+
+                    // Draw with thinner lines for the small 3x3 tiles
+                    this.drawStrokesOntoCanvas(ctx, tileSize, tileSize, strokesToDraw, this.masterStrokeColor, 2);
+                    ctx.restore();
+
+                    // Sub-grid lines
+                    ctx.strokeStyle = '#eeeeee';
+                    ctx.lineWidth = 0.5;
+                    ctx.strokeRect(tx, ty, tileSize, tileSize);
+                }
+            }
+
+            // Outer border
+            ctx.strokeStyle = '#cccccc';
+            ctx.lineWidth = 1;
+            ctx.strokeRect(0, 0, cw, ch);
+        });
+    }
+
+    drawStrokesOntoCanvas(ctx, w, h, strokes, color, weight = 4) {
+        if (!strokes || strokes.length === 0) return;
+        ctx.save();
+        ctx.strokeStyle = color;
+        ctx.lineWidth = weight;
+        ctx.lineJoin = 'round';
+        ctx.lineCap = 'round';
+
+        strokes.forEach(stroke => {
+            if (stroke.points.length < 2) return;
+            ctx.beginPath();
+            ctx.moveTo(stroke.points[0].x * w, stroke.points[0].y * h);
+            for (let i = 1; i < stroke.points.length - 1; i++) {
+                const xc = (stroke.points[i].x * w + stroke.points[i + 1].x * w) / 2;
+                const yc = (stroke.points[i].y * h + stroke.points[i + 1].y * h) / 2;
+                ctx.quadraticCurveTo(stroke.points[i].x * w, stroke.points[i].y * h, xc, yc);
+            }
+            const last = stroke.points[stroke.points.length - 1];
+            ctx.lineTo(last.x * w, last.y * h);
+            ctx.stroke();
+        });
+        ctx.restore();
+    }
+
+    startNewQuiz() {
+        this.quizScore = 0;
+        const scoreEl = document.getElementById('quiz-score');
+        if (scoreEl) scoreEl.textContent = this.quizScore;
+        this.setupQuizMode();
+        this.loadNextQuestion();
+    }
+
+    loadNextQuestion() {
+        const randomIndex = Math.floor(Math.random() * this.quizData.length);
+        this.currentQuiz = this.quizData[randomIndex];
+
+        const contentArea = document.getElementById('quiz-question-content');
+        const feedback = document.getElementById('quiz-feedback');
+        const questionText = document.getElementById('quiz-question-text');
+
+        if (feedback) feedback.classList.add('hidden');
+        if (questionText) questionText.innerHTML = `Q. ?먯뀛???묓뭹 <b style="color:#f1c40f">${this.currentQuiz.escherNo}</b> ???ъ슜???移?洹몃９??`;
+
+        if (contentArea) {
+            contentArea.innerHTML = `
+                <img src="${this.currentQuiz.img}?v=${Date.now()}" alt="Escher Quiz" style="max-width:100%; max-height:100%; object-fit:contain;">
+            `;
+        }
+
+        const hintEl = document.getElementById('quiz-hint-text');
+        if (hintEl) hintEl.innerHTML = `<b>Hint:</b> ${this.currentQuiz.hint}`;
+    }
+
+    checkQuizAnswer(selectedGroupId) {
+        const feedback = document.getElementById('quiz-feedback');
+        if (!feedback) return;
+
+        feedback.classList.remove('hidden');
+
+        if (selectedGroupId === this.currentQuiz.groupId) {
+            feedback.textContent = "?뺣떟?낅땲?? ???ㅼ쓬 臾몄젣濡??섏뼱媛묐땲??";
+            feedback.className = "quiz-feedback correct";
+            this.quizScore += 10;
+            const scoreEl = document.getElementById('quiz-score');
+            if (scoreEl) scoreEl.textContent = this.quizScore;
+
+            setTimeout(() => this.loadNextQuestion(), 1500);
+        } else {
+            feedback.textContent = "?꾩돺?듬땲?? ?ㅼ떆 ?쒕쾲 ?앷컖?대낫?몄슂. ??;
+            feedback.className = "quiz-feedback wrong";
+
+            // ?ㅻ떟???뚮뒗 ?ㅼ쓬 臾몄젣濡?諛붾줈 ?섏뼱媛吏 ?딄퀬, ?쇰뱶諛깅쭔 ?좉퉸 蹂댁뿬以?+            setTimeout(() => {
+                feedback.classList.add('hidden');
+            }, 1000);
+        }
+    }
+
+    // --- GAME 2: FALLING SQUARES LOGIC ---
+
+    setupFallingGameMode() {
+        this.fallingSquares = [];
+
+        const startBtn = document.getElementById('start-falling-btn');
+        const pauseBtn = document.getElementById('pause-falling-btn');
+        const stopBtn = document.getElementById('stop-falling-btn');
+
+        if (startBtn) {
+            startBtn.onclick = () => this.beginFallingPlay();
+        }
+
+        if (pauseBtn) {
+            pauseBtn.onclick = () => {
+                this.isFallingPaused = !this.isFallingPaused;
+                pauseBtn.textContent = this.isFallingPaused ? 'Resume' : 'Pause';
+                pauseBtn.style.background = this.isFallingPaused ? '#27ae60' : '#f39c12';
+            };
+        }
+
+        if (stopBtn) {
+            stopBtn.onclick = () => this.resetFallingGame();
+        }
+
+        const speedSlider = document.getElementById('falling-speed-slider');
+        if (speedSlider) {
+            speedSlider.oninput = (e) => {
+                this.fallingLevel = parseInt(e.target.value);
+            };
+        }
+    }
+
+    startFallingGame() {
+        this.isFallingGameMode = true;
+        this.fallingScore = 0;
+        this.isFallingPaused = false;
+
+        // UI 珥덇린?? Start 踰꾪듉留??몄텧
+        const startBtn = document.getElementById('start-falling-btn');
+        const pauseBtn = document.getElementById('pause-falling-btn');
+        const stopBtn = document.getElementById('stop-falling-btn');
+
+        if (startBtn) startBtn.classList.remove('hidden');
+        if (pauseBtn) {
+            pauseBtn.classList.add('hidden');
+            pauseBtn.textContent = 'Pause';
+            pauseBtn.style.background = '#f39c12';
+        }
+        if (stopBtn) stopBtn.classList.add('hidden');
+
+        this.stopFallingGameLoop();
+        this.clearFallingSquares();
+        this.lastSpawnTime = 0;
+        this.lastPauseCheck = 0;
+
+        const scoreEl = document.getElementById('falling-score');
+        if (scoreEl) scoreEl.textContent = '0';
+
+        const overlay = document.getElementById('falling-game-overlay');
+        if (overlay) overlay.classList.remove('hidden');
+    }
+
+    beginFallingPlay() {
+        this.gameLoopActive = true;
+        this.lastSpawnTime = 0;
+        this.lastPauseCheck = performance.now();
+
+        // UI ?꾪솚: Start ?④린怨?Pause/Stop ?몄텧
+        document.getElementById('start-falling-btn')?.classList.add('hidden');
+        document.getElementById('pause-falling-btn')?.classList.remove('hidden');
+        document.getElementById('stop-falling-btn')?.classList.remove('hidden');
+
+        this.fallingAnimationFrame = requestAnimationFrame((t) => this.fallingGameLoop(t));
+    }
+
+    resetFallingGame() {
+        this.stopFallingGameLoop();
+        this.startFallingGame(); // 泥섏쓬 ?湲??곹깭濡??뚭?
+    }
+
+    clearFallingSquares() {
+        this.fallingSquares = [];
+        const board = document.getElementById('falling-game-board');
+        if (board) board.innerHTML = '';
+    }
+
+    stopFallingGameLoop() {
+        this.gameLoopActive = false;
+        if (this.fallingAnimationFrame) {
+            cancelAnimationFrame(this.fallingAnimationFrame);
+            this.fallingAnimationFrame = null;
+        }
+    }
+
+    beginFallingPlay() {
+        this.stopFallingGameLoop(); // 以묐났 諛⑹?
+
+        this.clearFallingSquares();
+        this.gameLoopActive = true;
+        this.isFallingPaused = false;
+        this.lastSpawnTime = 0;
+        this.lastPauseCheck = 0;
+
+        // UI ?꾪솚: Start ?④린怨?Pause/Stop ?몄텧
+        const startBtn = document.getElementById('start-falling-btn');
+        const pauseBtn = document.getElementById('pause-falling-btn');
+        const stopBtn = document.getElementById('stop-falling-btn');
+
+        if (startBtn) startBtn.classList.add('hidden');
+        if (pauseBtn) {
+            pauseBtn.classList.remove('hidden');
+            pauseBtn.textContent = 'Pause';
+            pauseBtn.style.background = '#f39c12';
+        }
+        if (stopBtn) stopBtn.classList.remove('hidden');
+
+        this.fallingAnimationFrame = requestAnimationFrame((t) => this.fallingGameLoop(t));
+    }
+
+    stopFallingGame() {
+        this.isFallingGameMode = false;
+        this.stopFallingGameLoop();
+        this.clearFallingSquares();
+        const overlay = document.getElementById('falling-game-overlay');
+        if (overlay) overlay.classList.add('hidden');
+    }
+
+    fallingGameLoop(timestamp) {
+        if (!this.gameLoopActive) return;
+
+        if (this.isFallingPaused) {
+            // ?쇱떆?뺤? 以묒뿉??lastSpawnTime??硫덉텣 ?쒓컙留뚰겮 諛?댁쨲
+            if (this.lastPauseCheck > 0) {
+                const pauseDuration = timestamp - this.lastPauseCheck;
+                this.lastSpawnTime += pauseDuration;
+            }
+            this.lastPauseCheck = timestamp;
+            this.fallingAnimationFrame = requestAnimationFrame((t) => this.fallingGameLoop(t));
+            return;
+        }
+        this.lastPauseCheck = 0; // ?뺤? ?댁젣
+
+        if (!this.lastSpawnTime) this.lastSpawnTime = timestamp;
+        const elapsed = timestamp - this.lastSpawnTime;
+
+        // ?띾룄 議곗젅 諛몃윴??(1~5?④퀎)
+        const spawnIntervals = [4500, 3500, 2500, 1800, 1000];
+        let spawnInterval = spawnIntervals[this.fallingLevel - 1] || 2500;
+
+        if (elapsed > spawnInterval) {
+            this.spawnFallingSquare();
+            this.lastSpawnTime = timestamp;
+        }
+
+        this.updateFallingSquares();
+        this.fallingAnimationFrame = requestAnimationFrame((t) => this.fallingGameLoop(t));
+    }
+
+    spawnFallingSquare() {
+        const board = document.getElementById('falling-game-board');
+        if (!board) return;
+
+        // ?숉븯 ?띾룄 (?덉젙??
+        const speeds = [0.4, 0.7, 1.2, 2.0, 3.2];
+        let speedMultiplier = speeds[this.fallingLevel - 1] || 1.2;
+
+        const square = {
+            id: Date.now(),
+            x: 50 + Math.random() * (board.clientWidth - 170),
+            y: -150,
+            rotation: (Math.floor(Math.random() * 4)) * 90, // 0, 90, 180, 270
+            scaleX: Math.random() > 0.5 ? 1 : -1,
+            speed: (1 + Math.random() * 1.5) * speedMultiplier,
+            el: document.createElement('div')
+        };
+
+        // 留뚯빟 泥섏쓬遺???뺣떟??T) ?곹깭?쇰㈃ ?섎굹瑜?臾댁“嫄?鍮꾪??댁쨲
+        if (square.rotation === 0 && square.scaleX === 1) {
+            square.rotation = 90;
+        }
+
+        square.el.className = 'falling-square';
+        square.el.style.left = `${square.x}px`;
+
+        const canvas = document.createElement('canvas');
+        canvas.width = 120;
+        canvas.height = 120;
+        square.el.appendChild(canvas);
+
+        // 留덉슦???대깽???듯빀 (?댁쨷 議곗옉 泥닿퀎: ?대┃ ?꾩튂 遺꾪븷 + ?고겢由?
+        square.el.onmousedown = (e) => {
+            e.preventDefault();
+            e.stopPropagation();
+
+            const rect = square.el.getBoundingClientRect();
+            const clickX = e.clientX - rect.left;
+            const isRightSide = clickX > rect.width / 2;
+            const isRightClick = (e.button === 2) || (e.which === 3);
+
+            if (isRightClick || isRightSide) {
+                // ?ㅻⅨ履??대┃ ?먮뒗 ?ш컖?뺤쓽 ?ㅻⅨ履??덈컲 ?대┃: ?移?諛섏쟾)
+                this.handleReflect(square);
+            } else {
+                // ?ш컖?뺤쓽 ?쇱そ ?덈컲 ?대┃: ?뚯쟾
+                this.handleRotate(square);
+            }
+        };
+
+        // 釉뚮씪?곗? 湲곕낯 ?곗륫 硫붾돱 ?먯쿇 李⑤떒
+        square.el.oncontextmenu = (e) => {
+            e.preventDefault();
+            e.stopPropagation();
+            return false;
+        };
+
+        board.appendChild(square.el);
+        this.renderFallingSquare(square, canvas);
+        this.fallingSquares.push(square);
+    }
+
+    handleRotate(square) {
+        if (this.isFallingPaused) return;
+
+        // ?뚯쟾 ?④낵 (?쒓컖???쇰뱶諛?- ?뚮???
+        square.el.style.borderColor = "#3498db";
+        setTimeout(() => { if (square.el) square.el.style.borderColor = "transparent"; }, 150);
+
+        square.rotation = (square.rotation + 90) % 360;
+        this.finishFallingInteraction(square);
+    }
+
+    handleReflect(square) {
+        if (this.isFallingPaused) return;
+
+        // 蹂대씪???ш킅 ?쇰뱶諛?+        square.el.style.border = "4px solid #9b59b6";
+        setTimeout(() => { if (square.el) square.el.style.border = "3px solid transparent"; }, 200);
+
+        // Y異??移?(ScaleX 諛섏쟾) - 臾댁“嫄?醫뚯슦留??ㅼ쭛??+        square.scaleX *= -1;
+        this.finishFallingInteraction(square);
+    }
+
+    finishFallingInteraction(square) {
+        // T ?곹깭 泥댄겕
+        if (square.rotation === 0 && square.scaleX === 1) {
+            this.resolveFallingSquare(square);
+        } else {
+            const canvas = square.el.querySelector('canvas');
+            if (canvas) this.renderFallingSquare(square, canvas);
+        }
+    }
+
+    renderFallingSquare(square, canvas) {
+        const ctx = canvas.getContext('2d');
+        const w = canvas.width;
+        const h = canvas.height;
+        let strokes = JSON.parse(JSON.stringify(this.learnStrokes));
+
+        ctx.clearRect(0, 0, w, h);
+        ctx.fillStyle = "#ffffff";
+        ctx.fillRect(0, 0, w, h);
+
+        ctx.save();
+        ctx.translate(w / 2, h / 2);
+
+        // [理쒖쥌 ?섏젙] ?ъ슜?먯쓽 ?붿껌: "?ㅻⅨ履??대┃ = Y異??移?醫뚯슦 諛섏쟾)"
+        // ?ш컖?뺤씠 ?뚯쟾?섏뼱 ?덈뜑?쇰룄 ??긽 ?붾㈃?곸뿉??醫뚯슦媛 諛붾뚮룄濡?Scale??Rotate蹂대떎 '諛붽묑'???곸슜?⑸땲?? (肄붾뱶????
+        ctx.scale(square.scaleX, 1); // 2. 理쒖쥌?곸쑝濡??붾㈃ 湲곗? 醫뚯슦 諛섏쟾 ?곸슜
+        ctx.rotate(square.rotation * Math.PI / 180); // 1. 癒쇱? 媛곷룄留뚰겮 ?뚯쟾
+
+        ctx.translate(-w / 2, -h / 2);
+
+        // 留뚯빟 洹몃┛ 臾대뒳媛 ?녿떎硫?湲곕낯 罹먮┃??鍮꾨?移??숉겕 ?쇨뎬)瑜?洹몃젮以?+        if (strokes.length === 0) {
+            ctx.strokeStyle = this.masterStrokeColor;
+            ctx.lineWidth = 4;
+            ctx.lineCap = 'round';
+            // Face (Mouth)
+            ctx.beginPath();
+            ctx.arc(w / 2, h * 0.55, w * 0.3, 0.1 * Math.PI, 0.9 * Math.PI);
+            ctx.stroke();
+            // Right Eye (Dot)
+            ctx.beginPath();
+            ctx.arc(w * 0.65, h * 0.35, 5, 0, 2 * Math.PI);
+            ctx.fill();
+            // Left Eye (Wink - V shape)
+            ctx.beginPath();
+            ctx.moveTo(w * 0.25, h * 0.3);
+            ctx.lineTo(w * 0.35, h * 0.4);
+            ctx.lineTo(w * 0.45, h * 0.3);
+            ctx.stroke();
+        } else {
+            this.drawStrokesOntoCanvas(ctx, w, h, strokes, this.masterStrokeColor, 4);
+        }
+        ctx.restore();
+
+        // Border
+        ctx.strokeStyle = '#3498db';
+        ctx.lineWidth = 3;
+        ctx.strokeRect(0, 0, w, h);
+    }
+
+    updateFallingSquares() {
+        const board = document.getElementById('falling-game-board');
+        if (!board) return;
+
+        const boardHeight = board.clientHeight;
+
+        for (let i = this.fallingSquares.length - 1; i >= 0; i--) {
+            const s = this.fallingSquares[i];
+            s.y += s.speed;
+            s.el.style.top = `${s.y}px`;
+
+            // 諛붾떏???우쑝硫??쒓굅 (?ㅽ뙣)
+            if (s.y > boardHeight) {
+                s.el.remove();
+                this.fallingSquares.splice(i, 1);
+            }
+        }
+    }
+
+    resolveFallingSquare(square) {
+        square.el.style.transform = 'scale(1.2)';
+        square.el.style.opacity = '0';
+        square.el.style.transition = 'all 0.3s ease-out';
+
+        this.fallingScore += 10;
+        const scoreEl = document.getElementById('falling-score');
+        if (scoreEl) scoreEl.textContent = this.fallingScore;
+
+        setTimeout(() => {
+            square.el.remove();
+            this.fallingSquares = this.fallingSquares.filter(s => s.id !== square.id);
+        }, 300);
+    }
+
+
+    // Drawing system already initialized in init()
+
+    // Drawing in Learn Mode (Moved to setupDrawingSystem)
+
+    syncLearnCanvas() {
+        const rect = this.learnMasterCanvas.parentElement.getBoundingClientRect();
+        this.learnMasterCanvas.width = rect.width;
+        this.learnMasterCanvas.height = rect.height;
+    }
+
+    drawStrokes(ctx, w, h, color, isLearn = false) {
+        ctx.save();
+        const sourceStrokes = isLearn ? this.learnStrokes : this.strokes;
+        if (!sourceStrokes || sourceStrokes.length === 0) {
+            ctx.restore();
+            return;
+        }
+
+        ctx.strokeStyle = (ctx === this.masterCtx || ctx === this.learnMasterCtx || color === this.masterStrokeColor) ? this.masterStrokeColor : color;
+        ctx.lineWidth = this.strokeWidth;
+        ctx.lineJoin = 'round';
+        ctx.lineCap = 'round';
+
+        sourceStrokes.forEach(stroke => {
+            if (stroke.points.length < 2) return;
+            ctx.beginPath();
+            ctx.moveTo(stroke.points[0].x * w, stroke.points[0].y * h);
+
+            for (let i = 1; i < stroke.points.length - 1; i++) {
+                const xc = (stroke.points[i].x * w + stroke.points[i + 1].x * w) / 2;
+                const yc = (stroke.points[i].y * h + stroke.points[i + 1].y * h) / 2;
+                ctx.quadraticCurveTo(stroke.points[i].x * w, stroke.points[i].y * h, xc, yc);
+            }
+
+            const last = stroke.points[stroke.points.length - 1];
+            ctx.lineTo(last.x * w, last.y * h);
+            ctx.stroke();
+        });
+        ctx.restore();
+    }
+
+    drawMidpointGuides(ctx, w, h) {
+        const size = 20;
+        ctx.save();
+
+        // Use master stroke color for guides
+        ctx.strokeStyle = this.masterStrokeColor;
+        ctx.globalAlpha = 0.4; // Make it semi-transparent
+        ctx.lineWidth = 2;
+        ctx.setLineDash([4, 4]);
+
+        // Top midpoint
+        ctx.beginPath(); ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2, size); ctx.stroke();
+        // Bottom midpoint
+        ctx.beginPath(); ctx.moveTo(w / 2, h); ctx.lineTo(w / 2, h - size); ctx.stroke();
+        // Left midpoint
+        ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(size, h / 2); ctx.stroke();
+        // Right midpoint
+        ctx.beginPath(); ctx.moveTo(w, h / 2); ctx.lineTo(w - size, h / 2); ctx.stroke();
+
+        // Optional: Larger dots for better visibility
+        ctx.setLineDash([]);
+        ctx.fillStyle = this.masterStrokeColor;
+        ctx.globalAlpha = 0.6; // Slightly more opaque dots
+        const dotSize = 6;
+        ctx.beginPath(); ctx.arc(w / 2, 0, dotSize, 0, Math.PI * 2); ctx.fill();
+        ctx.beginPath(); ctx.arc(w / 2, h, dotSize, 0, Math.PI * 2); ctx.fill();
+        ctx.beginPath(); ctx.arc(0, h / 2, dotSize, 0, Math.PI * 2); ctx.fill();
+        ctx.beginPath(); ctx.arc(w, h / 2, dotSize, 0, Math.PI * 2); ctx.fill();
+
+        ctx.restore();
+    }
+
+    drawCanvasGrid(ctx, w, h) {
+        const gridCount = 10;
+        ctx.save();
+        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)'; // 吏꾪븯寃??섏젙 (0.05 -> 0.15)
+        ctx.lineWidth = 1;
+
+        for (let i = 1; i < gridCount; i++) {
+            // Horizontal lines
+            const y = (h / gridCount) * i;
+            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
+
+            // Vertical lines
+            const x = (w / gridCount) * i;
+            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
+        }
+        ctx.restore();
+    }
+
+    // This is a global function, not a method of the class.
+    // It's defined on the ctx object, which is unusual for a class method.
+    // Assuming this is intended to be a helper function available on any context.
+    // However, the subsequent `drawStrokesOntoCanvas` method calls `this.ctx.drawStrokesOntoCanvas`,
+    // which implies `this.ctx` is the canvas context itself, which is not how it's typically used.
+    // I will define it as a static helper or a method that takes ctx as an argument.
+    // Given the instruction, I will define it as a method that takes ctx as an argument,
+    // and then the class method `drawStrokesOntoCanvas` will call this new helper.
+    // This is a bit of a workaround for the instruction's format.
+
+    // Helper function for drawing strokes onto a canvas context
+    static _drawStrokesOntoCanvasHelper(ctx, w, h, strokes, color, width) {
+        if (!strokes || strokes.length === 0) return;
+        ctx.save();
+        ctx.strokeStyle = color;
+        ctx.lineWidth = width;
+        ctx.lineJoin = 'round';
+        ctx.lineCap = 'round';
+
+        strokes.forEach(stroke => {
+            const pts = stroke.points || stroke;
+            if (!pts || pts.length < 2) return;
+
+            ctx.beginPath();
+            // normalized mapping: [0, 1] -> [0, w] or centered
+            // The drawing is intended to be centered around (0.5, 0.5)
+            // but we just map [0,1] to [0,w] directly for simplicity in master.
+            ctx.moveTo(pts[0].x * w, pts[0].y * h);
+            for (let i = 1; i < pts.length - 1; i++) {
+                const x1 = pts[i].x * w;
+                const y1 = pts[i].y * h;
+                const x2 = pts[i + 1].x * w;
+                const y2 = pts[i + 1].y * h;
+                const xc = (x1 + x2) / 2;
+                const yc = (y1 + y2) / 2;
+                ctx.quadraticCurveTo(x1, y1, xc, yc);
+            }
+            ctx.lineTo(pts[pts.length - 1].x * w, pts[pts.length - 1].y * h);
+            ctx.stroke();
+        });
+        ctx.restore();
+    }
+
+    // Replace the earlier defined method to make it more universal
+    // This method now calls the static helper.
+    drawStrokesOntoCanvas(ctx, w, h, strokes, color, width) {
+        UnitessGalleryApp._drawStrokesOntoCanvasHelper(ctx, w, h, strokes, color, width);
+    }
+
+    setupAppendixGalleries() {
+        // 1. Triangle Gallery Setup
+        const triCanvas = document.getElementById('triangle-master-canvas');
+        const triGrid = document.getElementById('triangle-gallery-grid');
+        this.setupAppendixShape(triCanvas, triGrid, 'triangle', 8); // 8 patterns
+
+        // 2. Hexagon Gallery Setup
+        const hexCanvas = document.getElementById('hexagon-master-canvas');
+        const hexGrid = document.getElementById('hexagon-gallery-grid');
+        this.setupAppendixShape(hexCanvas, hexGrid, 'hexagon', 22); // 22 patterns
+    }
+
+    syncAppendixCanvases(type) {
+        const id = type === 'triangle' ? 'triangle-master-canvas' : 'hexagon-master-canvas';
+        const canvas = document.getElementById(id);
+        if (!canvas) return;
+        const rect = canvas.parentElement.getBoundingClientRect();
+        if (rect.width > 0) {
+            canvas.width = rect.width;
+            canvas.height = rect.height;
+            const strokes = type === 'triangle' ? this.triangleStrokes : this.hexagonStrokes;
+            this.renderAppendixMaster(canvas, strokes, type);
+        }
+    }
+
+    setupAppendixShape(canvas, gridContainer, type, count) {
+        if (!canvas || !gridContainer) return;
+        const ctx = canvas.getContext('2d');
+        const rect = canvas.parentElement.getBoundingClientRect();
+        canvas.width = rect.width;
+        canvas.height = rect.height;
+
+        // Drawing Event
+        let drawing = false;
+        const strokes = type === 'triangle' ? this.triangleStrokes : this.hexagonStrokes;
+        const grids = type === 'triangle' ? this.triangleGrids : this.hexagonGrids;
+
+        const startDraw = (e) => {
+            drawing = true;
+            strokes.push({ points: [] });
+            addPoint(e);
+        };
+        const endDraw = () => { drawing = false; };
+        const addPoint = (e) => {
+            if (!drawing) return;
+            const r = canvas.getBoundingClientRect();
+            // Normalize coordinates to 0-1 range
+            const x = (e.clientX - r.left) / r.width;
+            const y = (e.clientY - r.top) / r.height;
+            strokes[strokes.length - 1].points.push({ x, y });
+
+            this.renderAppendixMaster(canvas, strokes, type);
+            this.updateAppendixGallery(grids, strokes, type);
+        };
+
+        canvas.onmousedown = startDraw;
+        window.addEventListener('mouseup', endDraw);
+        canvas.onmousemove = addPoint;
+
+        // Clear Drawing
+        const clearBtnId = type === 'triangle' ? 'clear-triangle-draw' : 'clear-hexagon-draw';
+        const clearBtn = document.getElementById(clearBtnId);
+        if (clearBtn) {
+            clearBtn.onclick = () => {
+                strokes.length = 0; // Clear the array
+                this.renderAppendixMaster(canvas, strokes, type);
+                this.updateAppendixGallery(grids, strokes, type);
+            };
+        }
+
+        // Create Grid Items
+        for (let i = 1; i <= count; i++) {
+            const item = document.createElement('div');
+            item.className = 'shape-item';
+
+            const previewBox = document.createElement('div');
+            previewBox.className = 'shape-preview-box';
+            const pCanvas = document.createElement('canvas');
+            pCanvas.width = 180;
+            pCanvas.height = 180;
+            previewBox.appendChild(pCanvas);
+
+            const tag = document.createElement('div');
+            tag.className = 'shape-id-tag';
+            tag.textContent = `Pattern ID: ${type.charAt(0).toUpperCase()}${i}`;
+
+            item.appendChild(previewBox);
+            item.appendChild(tag);
+            gridContainer.appendChild(item);
+
+            grids.push({ canvas: pCanvas, ctx: pCanvas.getContext('2d'), id: i });
+        }
+
+        this.renderAppendixMaster(canvas, strokes, type);
+    }
+
+    renderAppendixMaster(canvas, strokes, type) {
+        if (!canvas) return;
+        const ctx = canvas.getContext('2d');
+        const w = canvas.width;
+        const h = canvas.height;
+        ctx.clearRect(0, 0, w, h);
+
+        // 1. Draw Background Grid (Removed as requested)
+        // if (type === 'triangle') {
+        //     this.drawMasterTriGrid(ctx, w, h);
+        // } else {
+        //     this.drawMasterHexGrid(ctx, w, h);
+        // }
+
+        // 2. Draw Base Shape Outline (Dashed) & Midpoints
+        ctx.save();
+        ctx.strokeStyle = '#3498db';
+        ctx.lineWidth = 2;
+        ctx.setLineDash([5, 5]);
+
+        const midpoints = [];
+        if (type === 'triangle') {
+            const v1 = { x: w / 2, y: h * 0.1 };
+            const v2 = { x: w * 0.9, y: h * 0.85 };
+            const v3 = { x: w * 0.1, y: h * 0.85 };
+
+            ctx.beginPath();
+            ctx.moveTo(v1.x, v1.y);
+            ctx.lineTo(v2.x, v2.y);
+            ctx.lineTo(v3.x, v3.y);
+            ctx.closePath();
+            ctx.stroke();
+
+            // Calculate midpoints
+            midpoints.push({ x: (v1.x + v2.x) / 2, y: (v1.y + v2.y) / 2 });
+            midpoints.push({ x: (v2.x + v3.x) / 2, y: (v2.y + v3.y) / 2 });
+            midpoints.push({ x: (v3.x + v1.x) / 2, y: (v3.y + v1.y) / 2 });
+        } else {
+            const radius = Math.min(w, h) * 0.45;
+            const vertices = [];
+            ctx.beginPath();
+            for (let i = 0; i < 6; i++) {
+                const angle = (i * 60 - 30) * Math.PI / 180;
+                const x = w / 2 + radius * Math.cos(angle);
+                const y = h / 2 + radius * Math.sin(angle);
+                vertices.push({ x, y });
+                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
+            }
+            ctx.closePath();
+            ctx.stroke();
+
+            // Calculate midpoints of 6 sides
+            for (let i = 0; i < 6; i++) {
+                const v1 = vertices[i];
+                const v2 = vertices[(i + 1) % 6];
+                midpoints.push({ x: (v1.x + v2.x) / 2, y: (v1.y + v2.y) / 2 });
+            }
+        }
+        ctx.restore();
+
+        // 3. Draw Midpoint Markers (Red dots)
+        ctx.save();
+        ctx.fillStyle = '#ff4757';
+        midpoints.forEach(pt => {
+            ctx.beginPath();
+            ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
+            ctx.fill();
+            // Subtle glow
+            ctx.shadowBlur = 5;
+            ctx.shadowColor = 'rgba(255, 71, 87, 0.5)';
+            ctx.strokeStyle = 'white';
+            ctx.lineWidth = 1;
+            ctx.stroke();
+        });
+        ctx.restore();
+
+        // 4. Draw Strokes
+        this.drawStrokesOntoCanvas(ctx, w, h, strokes, '#2c3e50', 4);
+    }
+
+    updateAppendixGallery(grids, strokes, type) {
+        grids.forEach(grid => {
+            const ctx = grid.ctx;
+            const w = grid.canvas.width;
+            const h = grid.canvas.height;
+            const patternColor = (type === 'triangle' ? this.appendixColors.tri : this.appendixColors.hex)[grid.id - 1] || '#2c3e50';
+
+            ctx.clearRect(0, 0, w, h);
+            ctx.fillStyle = '#ffffff';
+            ctx.fillRect(0, 0, w, h);
+
+            let idCounter = 1;
+
+            if (type === 'triangle') {
+                const rows = 4;
+                const totalW = w * 0.95;
+                const size = totalW / rows;
+                const triH = size * Math.sqrt(3) / 2;
+
+                ctx.save();
+                // Center the large triangle cluster
+                ctx.translate(w / 2, h / 2 - (rows * triH) / 2 + triH / 3);
+
+                let idCounterLocal = 0;
+                for (let r = 0; r < rows; r++) {
+                    const numTris = 2 * r + 1;
+                    const rowStartX = -(r * size / 2);
+
+                    for (let i = 0; i < numTris; i++) {
+                        ctx.save();
+                        const tx = rowStartX + i * (size / 2);
+                        const isInverted = i % 2 === 1;
+                        const ty = isInverted ? (r - 1 / 3) * triH : r * triH;
+
+                        ctx.translate(tx, ty);
+
+                        // Apply Pattern Symmetry
+                        this.applyAppendixSymmetry(ctx, grid.id, type, idCounterLocal++, 0);
+
+                        if (isInverted) {
+                            ctx.rotate(Math.PI);
+                        }
+
+                        // 1. Draw Tile Content
+                        ctx.save();
+                        // Map Master Triangle (Normalized 0-1) to local Triangle space
+                        // MT Bounds: X[0.1-0.9], Y[0.1-0.85] -> Width 0.8, Height 0.75
+                        // Local Space: Centroid is (0,0). Tri apex (0, -2/3 triH), Base Y (1/3 triH)
+                        const scaleFactorX = size / 0.8;
+                        const scaleFactorY = triH / 0.75;
+                        ctx.scale(scaleFactorX, scaleFactorY);
+                        ctx.translate(-0.5, -0.6); // Align centroids (MT centroid is 0.5, 0.6)
+
+                        // Draw strokes with adjusted line width
+                        const scaledWidth = this.appendixStrokeWidth / ((scaleFactorX + scaleFactorY) / 2);
+                        this.drawStrokesOntoCanvas(ctx, 1, 1, strokes, patternColor, scaledWidth);
+                        ctx.restore();
+
+                        // 2. Draw Faint Triangle Border
+                        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
+                        ctx.lineWidth = 1;
+                        ctx.beginPath();
+                        ctx.moveTo(0, -triH * 2 / 3);
+                        ctx.lineTo(size / 2, triH / 3);
+                        ctx.lineTo(-size / 2, triH / 3);
+                        ctx.closePath();
+                        ctx.stroke();
+
+                        // 3. Draw ID Label
+                        ctx.fillStyle = "rgba(0,0,0,0.3)";
+                        ctx.font = "bold 9px Arial";
+                        ctx.textAlign = "center";
+                        ctx.textBaseline = "middle";
+                        ctx.fillText(idCounterLocal, 0, 0);
+
+                        ctx.restore();
+                    }
+                }
+                ctx.restore();
+            }
+            else {
+                // Modified Hexagon Grid: 19-hex cluster (Pointy-Top)
+                const size = w / 9.5;
+                ctx.save(); // CRITICAL: Stop translation accumulation
+                ctx.translate(w / 2, h / 2);
+
+                // Define axial coordinates for a radius-2 hexagon (19 tiles)
+                const hexPositions = [];
+                for (let r = -2; r <= 2; r++) {
+                    for (let q = -2; q <= 2; q++) {
+                        if (Math.abs(q + r) <= 2) {
+                            hexPositions.push({ q, r });
+                        }
+                    }
+                }
+
+                // Sort positions to have a clean numbering: top-to-bottom, then left-to-right
+                hexPositions.sort((a, b) => a.r - b.r || a.q - b.q);
+
+                hexPositions.forEach((pos, idx) => {
+                    ctx.save();
+                    const tx = size * (Math.sqrt(3) * pos.q + Math.sqrt(3) / 2 * pos.r);
+                    const ty = size * (1.5 * pos.r);
+                    ctx.translate(tx, ty);
+
+                    // 1. Draw Tile Content (Master drawing)
+                    ctx.save();
+                    ctx.translate(-size, -size);
+                    this.drawStrokesOntoCanvas(ctx, size * 2, size * 2, strokes, patternColor, this.appendixStrokeWidth);
+                    ctx.restore();
+
+                    // 2. Draw Faint Hexagon Border
+                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
+                    ctx.lineWidth = 1;
+                    ctx.beginPath();
+                    for (let i = 0; i < 6; i++) {
+                        const angle = (i * 60 - 30) * Math.PI / 180;
+                        const px = size * Math.cos(angle);
+                        const py = size * Math.sin(angle);
+                        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
+                    }
+                    ctx.closePath();
+                    ctx.stroke();
+
+                    // 3. Draw ID Label (1-19)
+                    ctx.fillStyle = "rgba(0,0,0,0.3)";
+                    ctx.font = "bold 9px Arial";
+                    ctx.textAlign = "center";
+                    ctx.textBaseline = "middle";
+                    ctx.fillText(idx + 1, 0, 0);
+
+                    ctx.restore();
+                });
+                ctx.restore(); // Restore from initial translate(w/2, h/2)
+            }
+
+            ctx.save();
+            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for outer border
+            ctx.strokeStyle = 'rgba(200,200,200,0.3)';
+            ctx.lineWidth = 1;
+            ctx.strokeRect(0, 0, w, h);
+            ctx.restore();
+        });
+    }
+
+    applyAppendixSymmetry(ctx, patternId, type, tileIdx, subIdx) {
+        if (type === 'triangle') {
+            // Triangle Patterns (T1-T8)
+            // Resetting to identity/basic state as requested "Concrete transformations later"
+            // This ensures all 16-tri clusters look consistent structurally first.
+            switch (patternId) {
+                case 1: break;
+                case 2: break;
+                case 3: break;
+                case 4: break;
+                case 5: break;
+                case 6: break;
+                case 7: break;
+                case 8: break;
+            }
+        } else {
+            // Hexagon Patterns (H1-H22)
+            const group = Math.floor((patternId - 1) / 5);
+            const sub = (patternId - 1) % 5;
+
+            switch (group) {
+                case 0: // Basic rotations
+                    ctx.rotate(tileIdx * sub * 60 * Math.PI / 180);
+                    break;
+                case 1: // Reflections
+                    if (tileIdx % 2 === 1) ctx.scale(-1, 1);
+                    ctx.rotate(sub * 30 * Math.PI / 180);
+                    break;
+                case 2: // Complex
+                    ctx.rotate(tileIdx * 120 * Math.PI / 180);
+                    if (sub > 2) ctx.scale(1, -1);
+                    break;
+                case 3: // Glide-like
+                    ctx.translate(sub * 10, 0);
+                    if (tileIdx % 3 === 0) ctx.rotate(180 * Math.PI / 180);
+                    break;
+                default:
+                    ctx.rotate(tileIdx * 90 * Math.PI / 180);
+                    break;
+            }
+            if (patternId % 7 === 0) ctx.scale(-1, 1);
+        }
+    }
+    drawMasterTriGrid(ctx, w, h) {
+        ctx.save();
+        const centerX = w / 2;
+        const centerY = h / 2;
+        const side = Math.min(w, h) * 0.8;
+        const triH = side * Math.sqrt(3) / 2;
+        const gridCount = 6;
+        const step = side / gridCount;
+
+        ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
+        ctx.lineWidth = 1;
+
+        const startY = centerY - triH * 2 / 3;
+        const startX = centerX;
+
+        // Draw 3 directions of lines to form equilateral grid
+        for (let i = 0; i <= gridCount; i++) {
+            const hLineY = startY + (i / gridCount) * triH;
+            const hLineHalfW = (i / gridCount) * (side / 2);
+
+            // 1. Horizontal lines
+            ctx.beginPath();
+            ctx.moveTo(centerX - hLineHalfW, hLineY);
+            ctx.lineTo(centerX + hLineHalfW, hLineY);
+            ctx.stroke();
+
+            // 2. Left-leaning lines
+            const p1x = centerX - (i / gridCount) * (side / 2);
+            const p1y = startY + (i / gridCount) * triH;
+            const p2x = centerX + (side / 2) - (i / gridCount) * (side / 2);
+            const p2y = startY + triH;
+            ctx.beginPath();
+            ctx.moveTo(p1x, p1y);
+            ctx.lineTo(p2x, p2y);
+            ctx.stroke();
+
+            // 3. Right-leaning lines
+            const p3x = centerX + (i / gridCount) * (side / 2);
+            const p3y = startY + (i / gridCount) * triH;
+            const p4x = centerX - (side / 2) + (i / gridCount) * (side / 2);
+            const p4y = startY + triH;
+            ctx.beginPath();
+            ctx.moveTo(p3x, p3y);
+            ctx.lineTo(p4x, p4y);
+            ctx.stroke();
+        }
+        ctx.restore();
+    }
+
+    drawMasterHexGrid(ctx, w, h) {
+        ctx.save();
+        const centerX = w / 2;
+        const centerY = h / 2;
+        const mainRadius = Math.min(w, h) * 0.45;
+        const gridSize = mainRadius / 5; // 5 rings of hexes
+
+        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
+        ctx.lineWidth = 1;
+
+        // Draw hexagonal grid within the master hexagon boundary
+        for (let q = -6; q <= 6; q++) {
+            for (let r = -6; r <= 6; r++) {
+                if (Math.abs(q + r) > 6) continue;
+
+                const tx = centerX + gridSize * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
+                const ty = centerY + gridSize * (1.5 * r);
+
+                // Only draw if the small hex center is roughly within the main hex
+                const dist = Math.sqrt((tx - centerX) ** 2 + (ty - centerY) ** 2);
+                if (dist > mainRadius + gridSize) continue;
+
+                ctx.beginPath();
+                for (let i = 0; i < 6; i++) {
+                    const angle = (i * 60 - 30) * Math.PI / 180;
+                    const px = tx + gridSize * Math.cos(angle);
+                    const py = ty + gridSize * Math.sin(angle);
+                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
+                }
+                ctx.closePath();
+                ctx.stroke();
+            }
+        }
+        ctx.restore();
+    }
+}
+
+new UnitessGalleryApp();
